;
; ssmcc.asm: very small libc and start code in OpenWatcom v2 assembly (WASM) syntax, targeting Minix i86 and ELKS
; by pts@fazekas.hu at Thu Jan 29 06:32:16 CET 2026
;
; The OpenWatcom __cdecl i86 calling convention (similar to the Minix 1.5.10 i86 calling convention) is the following:
;
; * Upon each function entry and exit: ES == DS == SS.
; * Upon each function entry and exit: DF == 0. (This is only the convention of this libc. The default Minix libc doesn't have it.)
; * Please note that the callee can use BX as a scratch register, in addition to the usual AX, CX and DX in cdecl. (In the i386 calling convention, the caller has to restore EBX.)
; * The following assumes that all function arguments and return values are 1 byte (char, unsigned char) or 2 bytes (e.g. int, unsigned, pointer) or long (4 bytes) or unsigned long (4 bytes).
; * The caller pushes arguments starting with the last (sign-extended or zero-extended if needed first), one word a at a time, does a `call', and then pops the arguments.
; * The callee can use AX, BX, CX, DX, ES and FLAGS as scratch registers (but must set DF := 0). It must restore all other registers (including SI, DI, BP, DS). The Minix 1.5.10 i86 calling convention is different: there, the callee must restore ES.
; * The callee returns the value in AX (sign-extended or zero-extended if needed), it returns long and unsigned long values in DX:AX.
; * ES can be anything before each function call. The Minix 1.5.10 i86 calling convention is different: there, the callee can assume that ES == .data.
;
; The ELKS syscall ABI:
;
; * The caller sets AX to the syscall number.
; * The caller sets BX to argument 1, CX to argument 2, DX to argument 3, DI to argument 4, and SI to argument 5. It can use an arbitrary value for unused arguments.
; * The caller calls `int 80h'.
; * Upon successful return, the kernel sets AX to a nonnegative value.
; * Upon failure, the kernel sets AX to -errno, which is a negative value.
; * Not all libc system functions correspond directly to syscalls, for example wait(...) calls SYS_wait, and time(...) calls SYS_gettimeofday.
;

; --- Segment setup.

DOSSEG  ; Equivalent to `wlink op d'. It makes a difference on the segment order.

.errndef __SSMCC__  ; Assemble it using the ssmcc tool.
IFDEF __MINIX__
  .errdef __ELKS__  ; It's an error if both are defined.
ELSE
  .errndef __ELKS__  ; It's an error if neither is defined.
ENDIF

DGROUP GROUP CONST, CONST2, _DATA, EDATA, _BSS, STACK  ; These (without _TEXT and EDATA) are the standard segment names used by the OpenWatcom v2 C compiler (wcc). Also they are the DOSSEG segments used by the OpenWatcom v2 linker (WLINK).
; With or without DOSSEG, The OpenWatcom v2 linker (WLINK) determines the
; order of 'DATA'-class segments within DGROUP by the order it sees them.
; Since this is the first object file, we mention all the segments, and we
; control the order.
_TEXT  SEGMENT BYTE PUBLIC USE16 'CODE'  ; Make DGROUP happy.
_TEXT  ENDS
CONST  SEGMENT WORD PUBLIC USE16 'DATA'  ; Make DGROUP happy. C "string" literals.
CONST  ENDS
CONST2 SEGMENT WORD PUBLIC USE16 'DATA'  ; Make DGROUP happy. Other (non-string-literal) const, initialized global variables in C code.
CONST2 ENDS
_DATA  SEGMENT WORD PUBLIC USE16 'DATA'  ; Make DGROUP happy. Non-const, initialized global variables in C code.
_DATA  ENDS
EDATA  SEGMENT BYTE PUBLIC USE16 'DATA'  ; Make DGROUP happy.
; Post-linking will use the value of this symbol (see the `dw offset edata'
; below) to determine the size of CONST+CONST2+_DATA. The __edata symbol
; generated by the OpenWatcom v2 linker (WLINK) wouldn't be good enough for
; this purpose, because it includes the trailing (in-memory, not in-file)
; alignment bytes to the start of _BSS, which could be up to 15 (PARA
; alignment generated the the OpenWatcom v2 C compiler (wcc)).
myedata:
EDATA  ENDS
_BSS   SEGMENT WORD PUBLIC USE16 'BSS'  ; Make DGROUP happy. Non-const, uninitialized global variables in C code. Will be zero-initialized by the Minix or ELKS kernel when loading the program.
_BSS   ENDS
STACK  SEGMENT BYTE PUBLIC USE16 'STACK'  ; Make DGROUP happy.
;db 1 dup (?) ; `wlink op stack=1' takes care of populating it.
STACK  ENDS

; Paragraph alignment is important here. Without it the OpenWatcom v2 linker
; (WLINK) will start the DGROUP at an offset 0..15, to pack the DOS MZ .exe
; file more tightly, saving up to 15 bytes. We use BSD to make DGROUP start
; at offset for 0 (for Minix and ELKS) instead.
BDS    SEGMENT PARA PUBLIC USE16 'BEGDATA'
BDS    ENDS

; This would be put after _TEXT.
;CEND SEGMENT BYTE PUBLIC USE16 'CODE'
;PUBLIC _etext
;_etext:
;CEND ENDS

; --- malloc(), free(), relloc() dependency analysis.

IFDEF U_realloc  ; Regular relloc calls _free, _malloc, _memcpy.
  IFNDEF U_malloc
    U_malloc =
  ENDIF
  IFNDEF U_free
    U_free =
  ENDIF
  IFNDEF U_memcpy
    U_memcpy =
  ENDIF
ENDIF
IFDEF U_malloc_unaligned
  DO_malloc =
  IFDEF U_free
    U_malloc =
  ELSE
    IFNDEF U_brk
      U_brk =  ; The counting memory allocator uses brk(...).
    ENDIF
  ENDIF
ENDIF
IFDEF U_malloc  ; Regular malloc transitively calls _sbrk, _brk, _free.
  DO_malloc =
  IFDEF U_free
    IFNDEF U_sbrk
      U_sbrk =
    ENDIF
    IFNDEF U_brk
      U_brk =
    ENDIF
    IFNDEF U_free
      U_free =
    ENDIF
  ELSE
    IFNDEF U_brk
      U_brk =  ; The counting memory allocator uses brk(...).
    ENDIF
  ENDIF
ENDIF
; At this point we have {U_malloc, U_free, U_realloc} or one of its subsets:
;
; * {U_malloc, U_free, U_realloc}: linked-list memory allocator, with realloc.
; * {U_malloc, U_free}: linked-list memory allocator, without realloc.
; * {U_malloc}: the counting memory allocator (simpler and packs tighter, because nothing needs to be free()d).
; * {U_free}: will be a no-op.
; * {}: no memory allocator implementation.

; --- Global variables and constants.

BDS SEGMENT PARA PUBLIC USE16 'BEGDATA'  ; Paragraph alignment is important.
nullptr_target: dd 0  ; Make sure that a NULL pointer doesn't point to valid data, but here.
BDS ENDS

_DATA SEGMENT WORD PUBLIC USE16 'DATA'
IFDEF U_brk
IFNDEF U_brksize
U_brksize =
ENDIF
ENDIF
IFDEF U_execve
IFNDEF U_sbrk
U_sbrk =
ENDIF
ENDIF
IFDEF U_sbrk
IFNDEF U_brksize
U_brksize =
ENDIF
ENDIF
IFDEF U_malloc
IFNDEF U_brksize
U_brksize =
ENDIF
ENDIF
IFDEF U_brksize
EXTRN __end:BYTE
PUBLIC _brksize
_brksize: dw offset __end  ; The OpenWatcom v2 linker (WLINK) puts the symbol __end to the end of _BSS.
ENDIF
_DATA ENDS

_BSS SEGMENT WORD PUBLIC USE16 'BSS'
IFDEF U_errno  ; int errno;
PUBLIC _errno
_errno: dw ?
ENDIF
IFDEF U_getenv
IFNDEF U_environ
U_environ =
ENDIF
ENDIF
IFDEF U_execv
IFNDEF U_environ
U_environ =
ENDIF
ENDIF
IFDEF U_environ  ; char **environ;
PUBLIC _environ
_environ: dw ?
ENDIF
IFDEF U_signal
IFNDEF U___system_signal
U___system_signal =
ENDIF
ENDIF
IFDEF U___system_signal
IFNDEF U___sigtable
U___sigtable =
ENDIF
ENDIF
IFDEF __ELKS__
IFDEF U___sigtable
PUBLIC ___sigtable  ; sighandler_t __sigtable[NSIG - 1];
NSIG = 32
___sigtable: dw (NSIG - 1) dup (?)
ENDIF
ELSE  ; __ELKS__
PUBLIC __M  ; message _M;
__M: db 24 dup (?)  ; No COMMON in OpenWatcom v2 C. We could use the `COMMON' directive here.
IFDEF U___sigtable
PUBLIC ___sigtable  ; sighandler_t __sigtable[NSIG - 1];
NSIG = 17
___sigtable: dw (NSIG - 1) dup (?)
ENDIF
ENDIF  ; ELSE __ELKS__
_BSS ENDS

; See <minix/com.h> for C definitions
;SEND = 1
;RECEIVE = 2
BOTH equ 3
SYSVEC equ 32  ; int 20h ; int $20

_TEXT SEGMENT BYTE PUBLIC USE16 'CODE'
ASSUME DS:DGROUP, ES:DGROUP, SS:DGROUP  ; Without this line, the OpenWatcom v2 assembler (WASM) would generate incorrect relocations for all of `mov byte ptr [__M+2], ...' etc.

; --- Startup and syscalls.

; This is the C run-time start-off routine.  It's job is to take the
; arguments as put on the stack by EXEC, and to parse them and set them up the
; way _main expects them.
PUBLIC _cstart_
EXTRN main_:NEAR
_cstart_:
IF 1  ; This will generate the 1st few bytes of the program image (DOS MZ .exe offset 0x20, right after the DOS MZ .exe header). We are at the beginning of _TEXT.
	dw offset myedata  ; __edata is alinged to the start of _BSS, which we don't want, so we use myedata, which isn't. These 2 bytes will be replaced with `cld ++ pop ax' during post-linking.
ELSE
	cld  ; Will be put back during post-linking.
	pop ax  ; AX := argc. Will be put back during post-linking.
ENDIF
	;sub bp, bp  ; Clear for backtrace of core files.
IFDEF U__argc  ; The OpenWatcom C compiler generates this is main(...) has arguments.
	mov dx, sp  ; DX := argv.
	mov bx, ax  ; BX := argc.
	inc bx
	add bx, bx  ; BX := 2 * (argc + 1).
	add bx, sp  ; BX := (char **) argv + (argc + 1). BX := envp.
IFDEF U_environ
	mov [_environ], bx
ENDIF
PUBLIC __argc  ; The OpenWatcom C compiler generates this as an unused dependency of main(...).
__argc:  ; Actual symbol value doesn't matter.
ENDIF  ; U___argc
	;push bx  ; envp.
	;push dx  ; argv.
	;push ax  ; argc.
	;call _main
	call main_  ; The calling convention for main(argc, argv) is always __watcall (even with `owcc -mabi=cdecl) with the OpenWatcom v2 C compiler (wcc).
	;add sp, 6  ; Not needed, we are exiting soon anyway.
	push ax  ; push exit status
	push ax  ; Fake return address for _exit.
	; Fall through to _exit.
;
; void exit(int exit_code);
IFDEF U_exit
PUBLIC _exit
ENDIF
_exit:
; MINIX PUBLIC void exit(exit_code)
; int exit_code;
; {
;   *(char*)&_M.m_type = EXIT;
;   _M.m1_i1 = exit_code;
;   callx();
; }
	pop ax  ; Return address. Won't be used.
IFDEF __ELKS__
	pop bx  ; exit_code.
	mov ax, 1  ; SYS_exit.
	int 80h  ; ELKS syscall.
ELSE  ; __ELKS__
	pop [__M+4]  ; exit_code.
	mov byte ptr [__M+2], 1  ; *(char*)&_M.m_type = EXIT;
	; Fall through to _callx.
ENDIF  ; ELSE __ELKS__
;
; MINIX. Send a message and get the response.  The '_M.m_type' field of the
; reply contains a value (>=0) or an error code (<0).
IFNDEF __ELKS__
IFDEF U_callx  ; Typically false.
PUBLIC _callx
ENDIF
_callx:
; PRIVATE int callx()
; {
;   int k;
; #IFDEF DEBUG_MALLOC  /* Always false. */
;   k = _M.m_type;  /* syscall number. */
;   k = (k >= READ && k <= CREAT) ;; k == IOCTL;  /* MM (== 0) or FS (== 1). */
; #ELSE
;   k = (_M.m_type & 17) != 1;  /* _M.m_type is syscall number. */  /* MM (== 0) or FS (== 1). */  /* This works for EXIT (MM), READ, WRITE, OPEN, CLOSE, CREAT, BRK (MM) and IOCTL. */
; #ENDIF
;   k = sendrec(k, &_M);
;   if (k != 0) return(k);  /* send itself failed */
;   if (_M.m_type < 0) {
; #IFDEF ERRNO  /* Always false. */
;     errno = -_M.m_type;
; #ENDIF
;     return(-1);
;   }
;   return(_M.m_type);
; }
	mov ax, word ptr [__M+2]  ; syscall number.
	and al, 15
	dec ax
	jz callxmmfs  ; Keep AX == MM (== 0).
	mov al, 1  ; AX := FS (== 1).
callxmmfs:
	; Now AX is either MM (== 0) or FS (== 1), depending on the syscall number.
	mov bx, offset __M
	mov cx, BOTH  ; sendrec(srcdest, ptr)
	int SYSVEC  ; trap to the kernel; ruins AX, BX and CX, keeps DX.
	test ax, ax
	jnz callxret  ; sendrec(...) itself has failed.
	or ax, word ptr [__M+2]  ; Syscall result or -errno.
	mov byte ptr [__M+3], 0  ; Set high byte of next syscall to 0.
	jns callxret
IFDEF U_errno
	neg ax
	mov [_errno], ax
ENDIF
	mov ax, -1  ; Return value to indicate syscall error.
callxret:
	ret
ENDIF  ; IFNDEF __ELKS__

; int write(int fd, const char *buffer, unsigned nbytes);
IFDEF U_write
PUBLIC _write
_write:
IFDEF __ELKS__
	mov al, 4  ; SYS_write.
	; Fall through to sesys3.
IFNDEF DO_sesys3
DO_sesys3 =
ENDIF
ELSE  ; __ELKS__
	mov byte ptr [__M+2], 4  ; *(char*)&_M.m_type = WRITE;
readwrite:
	mov bx, sp
	mov ax, word ptr [bx+2]  ; Argument fd.
	mov word ptr [__M+4], ax  ; _M.m1_i1.
	mov ax, word ptr [bx+4]  ; Argument buffer.
	mov word ptr [__M+10], ax  ; _M.m1_p1.
	mov ax, word ptr [bx+6]  ; Argument nbytes.
	mov word ptr [__M+6], ax  ; _M.m1_i2.
	jmp _callx  ; WASM is smart enough to generate a `jmp short' if the target is close enough.
ENDIF  ; ELSE __ELKS__
ENDIF
;
IFDEF __ELKS__
IFDEF U_write
IFNDEF DO_sesys3
DO_sesys3 =
ENDIF
ENDIF
IFDEF U_close
IFNDEF DO_sesys3
DO_sesys3 =
ENDIF
ENDIF
IFDEF U_umask
IFNDEF DO_sesys3
DO_sesys3 =
ENDIF
ENDIF
IFDEF U_open
IFNDEF DO_sesys3
DO_sesys3 =
ENDIF
ENDIF
IFDEF U_open00
IFNDEF DO_sesys3
DO_sesys3 =
ENDIF
ENDIF
IFDEF U_creat
IFNDEF DO_sesys3
DO_sesys3 =
ENDIF
ENDIF
IFDEF U_chmod
IFNDEF DO_sesys3
DO_sesys3 =
ENDIF
ENDIF
IFDEF U_rename
IFNDEF DO_sesys3
DO_sesys3 =
ENDIF
ENDIF
IFDEF U_remove
IFNDEF DO_sesys3
DO_sesys3 =
ENDIF
ENDIF
IFDEF U_unlink
IFNDEF DO_sesys3
DO_sesys3 =
ENDIF
ENDIF
IFDEF U_getpid
IFNDEF DO_sesys3
DO_sesys3 =
ENDIF
ENDIF
IFDEF U_wait
IFNDEF DO_sesys3
DO_sesys3 =
ENDIF
ENDIF
IFDEF U_wait4
IFNDEF DO_sesys3
DO_sesys3 =
ENDIF
ENDIF
IFDEF U_getpid
IFNDEF DO_sesys3
DO_sesys3 =
ENDIF
ENDIF
IFDEF U_time
IFNDEF DO_sesys3
DO_sesys3 =
ENDIF
ENDIF
IFDEF U_signal
IFNDEF DO_sesys3
DO_sesys3 =
ENDIF
ENDIF
IFDEF U_execve
IFNDEF DO_sesys3
DO_sesys3 =
ENDIF
ENDIF
IFDEF U_dup
IFNDEF DO_sesys3
DO_sesys3 =
ENDIF
ENDIF
IFDEF U_pipe
IFNDEF DO_sesys3
DO_sesys3 =
ENDIF
ENDIF
;
IFDEF DO_sesys3
IFDEF U___sesys3
PUBLIC ___sesys3
___sesys3:
ENDIF
sesys3:  ; simple_elks_syscall3: at most 3 arguments.
	mov bx, sp
sesys3bxok:
	mov dx, [bx+6]  ; Argument 3 (nbytes of read(...) and write(...)).
	mov cx, [bx+4]  ; Argument 2 (buffer of read(...) and write(...)).
sesys1b:
	mov bx, [bx+2]  ; Argument 1 (fd of read(...) and write(...)).
sesys:
	mov ah, 0
	int 80h  ; ELKS syscall.
	test ax, ax
	jns sesys3ret
sesyserr:
IFDEF U_errno
	neg ax
	mov [_errno], ax
ENDIF
	mov ax, -1  ; Now we could set errno to -AX (for both Minix and ELKS).
sesys3ret:
	ret
ENDIF
ENDIF  ; __ELKS__

; int read(int fd, char *buffer, unsigned nbytes);
IFDEF U_read
PUBLIC _read
_read:
IFDEF __ELKS__
	mov al, 3  ; SYS_read.
	jmp sesys3  ; !! TODO(pts): Move it here if U_write is not defined.
ELSE  ; __ELKS__
	mov byte ptr [__M+2], 3  ; *(char*)&_M.m_type = READ;
IFDEF U_read
	jmp readwrite
ELSE
	mov bx, sp
	mov ax, word ptr [bx+2]  ; Argument fd.
	mov word ptr [__M+4], ax  ; _M.m1_i1.
	mov ax, word ptr [bx+4]  ; Argument buffer.
	mov word ptr [__M+10], ax  ; _M.m1_p1.
	mov ax, word ptr [bx+6]  ; Argument nbytes.
	mov word ptr [__M+6], ax  ; _M.m1_i2.
	jmp _callx
ENDIF
ENDIF  ; ELSE __ELKS__
ENDIF

; int close(int fd);
IFDEF U_close
PUBLIC _close
_close:
IFDEF __ELKS__
	mov al, 6  ; SYS_close.
	jmp sesys3
ELSE  ; __ELKS__
	mov byte ptr [__M+2], 6  ; *(char*)&_M.m_type = CLOSE;
	; Argument fd will be copied to _M.m1_i1.
	; Fall through to callxarg1.
IFNDEF DO_callxarg1
DO_callxarg1 =
ENDIF
ENDIF  ; ELSE __ELKS__
ENDIF  ; U_close
IFNDEF __ELKS__
IFDEF U_umask
DO_callxarg1 =
ENDIF
IFDEF U_fstat
IFNDEF DO_callxarg1
DO_callxarg1 =
ENDIF
ENDIF
ENDIF  ; IFNDEF __ELKS__
;
IFDEF DO_callxarg1
callxarg1:
	mov bx, sp
	mov ax, word ptr [bx+2]  ; Argument 1.
	mov word ptr [__M+4], ax  ; _M.m1_i1.
	jmp _callx
ENDIF

; mode_t umask(mode_t complmode);
IFDEF U_umask
PUBLIC _umask
_umask:
; MINIX PUBLIC mode_t umask(complmode) mode_t complmode {
;   return((mode_t)callm1(FS, UMASK, (int)complmode, 0, 0, NIL_PTR, NIL_PTR, NIL_PTR));
; }
IFDEF __ELKS__
	mov al, 60  ; SYS_umask.
	jmp sesys3
ELSE  ; __ELKS__
	mov byte ptr [__M+2], 60  ; *(char*)&_M.m_type = UMASK;
	jmp callxarg1  ; Argument complmode will be copied to _M.m1_i1.
ENDIF  ; ELSE __ELKS__
ENDIF

; int dup(int _oldfd);
IFDEF U_dup
PUBLIC _dup
_dup:
; MINIX PUBLIC int dup(fd) int fd; {
;   return(callm1(FS, DUP, fd, 0, 0, NIL_PTR, NIL_PTR, NIL_PTR));
; }
IFDEF __ELKS__
	mov al, 41  ; SYS_dup.
	jmp sesys3
ELSE  ; __ELKS__
	mov byte ptr [__M+2], 41  ; *(char*)&_M.m_type = DUP;
	jmp callxarg1  ; Argument _fd will be copied to _M.m1_i1.
ENDIF  ; IFNDEF __ELKS__
ENDIF

; pid_t fork(void);
IFDEF U_fork
PUBLIC _fork
_fork:
IFDEF __ELKS__
	mov al, 2  ; SYS_fork.
	jmp sesys
ELSE  ; __ELKS__
	mov byte ptr [__M+2], 2  ; *(char*)&_M.m_type = FORK;
	xor ax, ax  ; MM.
	jmp callxmmfs  ; return(callm1(MM, FORK, 0, 0, 0, NIL_PTR, NIL_PTR, NIL_PTR));
ENDIF  ; __ELKS__
ENDIF

; pid_t wait(int *_status_loc);
IFDEF U_wait
PUBLIC _wait
_wait:
IFDEF __ELKS__
; ELKS int wait(status) int *status; {
;   return wait4(-1, status, 0, (void*) 0);
; }
	push di  ; Save.
	mov al, 7  ; SYS_wait4.
	xor di, di  ; Argument 4 (_usage) of SYS_wait4.
	xor dx, dx  ; Argument 3 (_options) of SYS_wait4.
	mov bx, sp
	mov cx, [bx+4]  ; Argument 2 (_status_loc) of SYS_wait4.
	mov bx, -1  ; Argument 1 (_pid) of SYS_wait4.
	call sesys
	pop di  ; Restore.
	ret
ELSE  ; __ELKS__
; MINIX PUBLIC int wait(status) int *status; {
;   int k;
;   k = callm1(MM, WAIT, 0, 0, 0, NIL_PTR, NIL_PTR, NIL_PTR);
;   if (k >= 0 && status != 0) *status = _M.m2_i1;
;   return(k);
; }
	mov byte ptr [__M+2], 7  ; *(char*)&_M.m_type = WAIT;
	xor ax, ax  ; MM.
	call callxmmfs
	test ax, ax
	js waitret
	mov bx, sp
	cmp word ptr [bx+2], 0  ; Argument status.
	je waitret
	mov dx, word ptr [__M+4]  ; _M.m2_i1.
	mov bx, [bx+2]
	mov [bx], dx  ; *status = _M.m2_i1;
waitret:
	ret
ENDIF  ; __ELKS__
ENDIF

; pid_t wait4(pid_t _pid, int *_status_loc, int _options, struct rusage *_usage);
IFDEF __ELKS__
IFDEF U_wait4
PUBLIC _wait4
_wait4:
	mov ax, 7  ; SYS_wait4.
sesys4:
	mov bx, sp
	xchg di, [bx+8]  ; DI := argument 4 (_usage) o SYS_wait4. Also save DI.
	mov dx, [bx+6]  ; Argument 3 (_options) of SYS_wait4.
	mov cx, [bx+4]  ; Argument 2 (_status_loc) of SYS_wait4.
	mov bx, [bx+2]  ; Argument 1 (_pid) of SYS_wait4.
	call sesys
	xchg di, [bx+8]  ; Restore DI.
	ret
ENDIF
ENDIF  ; __ELKS__

; pid_t getpid(void);
IFDEF U_getpid
PUBLIC _getpid
_getpid:
IFDEF __ELKS__
; ELKS pid_t getpid() {
;   int ppid_ignored;
;   return syscall1(SYS_getpid, (int) &ppid_ignored);
; }
	push ax  ; Allocate stack space for ppid_ignored.
	mov al, 20  ; SYS_getpid.
	mov bx, sp  ; BX(argument 1 of SYS_getpid)  := &ppid_ignored.
	call sesys
	pop bx  ; Clean up ppid_ignored.
	ret
ELSE  ; __ELKS__
	mov byte ptr [__M+2], 20  ; *(char*)&_M.m_type = GETPID;
	xor ax, ax  ; MM.
	jmp callxmmfs  ; return(callm1(MM, GETPID, 0, 0, 0, NIL_PTR, NIL_PTR, NIL_PTR));
ENDIF  ; __ELKS__
ENDIF

; pid_t time(time_t *_tloc);
IFDEF U_time
PUBLIC _time
_time:
IFDEF __ELKS__
; ELKS time_t time(_tloc) time_t *_tloc; {
;   struct timeval rv;
;   if (syscall2(SYS_gettimeofday, (int) &rv, 0) < 0) return -1;
;   if (_tloc) *_tloc = rv.tv_sec;
;   return rv.tv_sec;
; }
	sub sp, 8  ; Allocate stack space for rv.
	mov al, 62  ; SYS_gettimeofday.
	mov bx, sp  ; BX (argument 1 of SYS_gettimeofday) := &rv.
	xor cx, cx  ; CX (argument 2 of SYS_gettimeofday) := 0.
	call sesys
	test ax, ax
	jns timeok
	mov ax, -1
	cwd  ; DX := -1.
	jmp timedone
timeok:
	mov bx, sp
	mov dx, [bx+2]  ; High word of rv.tv_sec.
	mov ax, [bx]    ; Low  word of rv.tv_sec.
	mov bx, [bx+10]  ; _tloc.
	test bx, bx  ; if (_tloc != (long *) 0).
	jz timedone
	mov [bx+2], dx  ; High word of:  *_tloc = l;
	mov [bx], ax    ; Low  word of:  *_tloc = l;
timedone:
	add sp, 8  ; Clean up low rv.
	ret
ELSE  ; __ELKS__
; MINIX PUBLIC long time(_tloc) time_t *_tloc;
; {
;   int k;
;   long l;
;   if (callm1(FS, TIME, 0, 0, 0, NIL_PTR, NIL_PTR, NIL_PTR) != 0) return -1L;
;   l = _M.m2_l1;
;   if (_tloc != (long *) 0) *_tloc = l;
;   return(l);
; }
	mov byte ptr [__M+2], 13  ; *(char*)&_M.m_type = TIME;
	call _callx
	test ax, ax
	jz timeok
	mov ax, -1
	cwd  ; DX := -1.
	ret
timeok:
	mov dx, word ptr [__M+12]  ; High word of: l = _M.m2_l1;
	mov ax, word ptr [__M+10]  ; Low  word of: l = _M.m2_l1;
	mov bx, sp
	mov bx, [bx+2]  ; _tloc.
	test bx, bx  ; if (_tloc != (long *) 0).
	jz timesaved
	mov [bx+2], dx  ; High word of:  *_tloc = l;
	mov [bx], ax    ; Low  word of:  *_tloc = l;
timesaved:
	ret
ENDIF  ; __ELKS__
ENDIF

; int fstat(int _fd, struct stat *_statbuf);
IFDEF U_fstat
IFNDEF __ELKS__  ; For ELKS, it is defined below.
PUBLIC _fstat
_fstat:
; MINIX PUBLIC int fstat(_fd, _statbuf)
; int _fd;
; struct stat *_statbuf;
; {
;   return(callm1(FS, FSTAT, _fd, 0, 0, (char *)_statbuf, NIL_PTR, NIL_PTR));
; }
	mov byte ptr [__M+2], 28  ; *(char*)&_M.m_type = FSTAT;
	mov bx, sp
	mov ax, [bx+4]  ; Argument _statbuf.
	mov word ptr [__M+10], ax  ; _M.m1_p1.
	jmp callxarg1  ; Argument _fd will be copied to _M.m1_i1.
ENDIF  ; IFNDEF __ELKS__
ENDIF

; int pipe(int _pipefd[2]);
IFDEF U_pipe
PUBLIC _pipe
_pipe:
; MINIX PUBLIC int pipe(fild) int _pipefd[2]; {
;   int k;
;   k = callm1(FS, PIPE, 0, 0, 0, NIL_PTR, NIL_PTR, NIL_PTR);
;   if (k < 0) return(k);
;   _pipefd[0] = _M.m1_i1;
;   _pipefd[1] = _M.m1_i2;
;   return(0);
; }
IFDEF __ELKS__
	mov al, 42  ; SYS_pipe.
	jmp sesys3
ELSE  ; __ELKS__
	mov byte ptr [__M+2], 42  ; *(char*)&_M.m_type = PIPE;
	call _callx
	test ax, ax
	js piperet
	mov bx, sp
	mov bx, [bx+2]  ; Argument _pipefd.
	mov ax, word ptr [__M+4]
	mov [bx], ax  ; fild[0] = _M.m1_i1;
	mov ax, word ptr [__M+6]
	mov [bx+2], ax  ; fild[1] = _M.m1_i2;
	xor ax, ax  ; Force return value 0. Minix 1.5.10 needs it.
piperet:
	ret
ENDIF  ; IFNDEF __ELKS__
ENDIF

; int open(const char *_path, int _oflag, ...);  /* ... is `mode_t _mode' or `unsigned _mode'. */
IFDEF U_open
PUBLIC _open
_open:
IFDEF __ELKS__
	mov al, 5  ; SYS_open.
	jmp sesys3
ELSE  ; __ELKS__
	mov byte ptr [__M+2], 5  ; *(char*)&_M.m_type = OPEN;
	mov bx, sp
	mov ax, [bx+4]  ; AX := _oflag.
	mov word ptr [__M+6], ax  ; _M.m1_i2 = _oflag;  ; _M.m3_i2 = _oflag;
	test ax, 0100o  ; O_CREAT == 0100.
IFNDEF DO_callm3
DO_callm3 =
ENDIF
	jz callm3  ; return(callm3(FS, OPEN, _oflag, _path));  /* Ignores _mode. */
	; Now do return callm1(FS, OPEN, strlen(_path) + 1, _oflag, mode, (char *)_path, NIL_PTR, NIL_PTR);
	mov ax, [bx+6]  ; AX := _mode.
	mov word ptr [__M+8], ax  ; _M.m1_i3 = mode;
	mov bx, [bx+2]  ; BX := _path.
	mov word ptr [__M+10], bx  ; _M.m1_p1 = (char *) _path;
IFNDEF U_strlen
U_strlen =
ENDIF
	call __strlenbx  ; AX := strlen(_path). Ruins BX, CX, DX (and ES etc.).
	inc ax  ; AX := strlen(_path) + 1.
	mov word ptr [__M+4], ax  ; _M.m1_i1 = strlen(_path) + 1;
	jmp _callx
ENDIF  ; ELSE __ELKS__
ENDIF

; int open00(const char *_path);
; Same as open(_path, 0). Same as open(_path, O_RDONLY).
IFDEF U_open00
PUBLIC _open00
_open00:
IFDEF __ELKS__
	mov al, 5  ; SYS_open.
	mov bx, sp
	xor cx, cx  ; CX (_oflag) := 0. No need to set DX (_mode) when _oflag == 0 == O_RDONLY.
	jmp sesys1b
ELSE  ; __ELKS__
	mov byte ptr [__M+2], 5  ; *(char*)&_M.m_type = OPEN;
	xor ax, ax  ; AX (_oflag) := 0. We ignore _mode, because it's not needed when _oflag == 0 == O_RDONLY. */
	; _M.m3_i2 := _oflag.  ; Fall through to callm3ax.
IFNDEF DO_callm3ax
DO_callm3ax =
ENDIF
ENDIF  ; ELSE __ELKS__
ENDIF
IFNDEF __ELKS__
IFDEF U_creat
IFNDEF DO_callm3ax
DO_callm3ax =
ENDIF
ENDIF
ENDIF  ; IFNDEF __ELKS__
;
IFDEF DO_callm3ax
callm3ax:
	mov word ptr [__M+6], ax  ; _M.m3_i2 = _oflag;
	; Fall through to callm3.
IFNDEF DO_callm3
DO_callm3 =
ENDIF
ENDIF
IFNDEF __ELKS__
IFDEF U_remove
IFNDEF DO_callm3
DO_callm3 =
ENDIF
ENDIF
IFDEF U_unlink
IFNDEF DO_callm3
DO_callm3 =
ENDIF
ENDIF
ENDIF  ; IFNDEF __ELKS__
;
; int callm3(const char *name);
;
; If the string fits in the message, it is copied there. If not, a pointer
; to it is passed.
IFDEF DO_callm3
callm3:
; MINIX PUBLIC int callm3(name) _CONST char *name; {
;   register unsigned k;
;   register char *rp;
;   k = strlen(name) + 1;
;   _M.m3_i1 = k;
;   _M.m3_p1 = (char *) name;
;   rp = &_M.m3_ca1[0];
;   if (k <= M3_STRING) {  /* 14. */
;     while (k--) { *rp++ = *name++; }
;   }
;   return callx();
; }
	push si  ; Save.
	mov si, sp
	mov si, [si+4]  ; Argument name.
	mov word ptr [__M+8], si  ; _M.m3_p1 = (char *) name;
	push si  ; Argument name.
ifndef U_strlen
U_strlen =
endif
	call _strlen
	pop cx  ; Clean up argument of _strlen above.
	inc ax  ; k := strlen(name) + 1.
	mov word ptr [__M+4], ax  ; _M.m3_i1 = k;
	cmp ax, 14  ; if (k <= M3_STRING)
	ja callm3skip
	xchg cx, ax  ; CX := AX (k); AX := junk.
	xchg di, ax  ; Save DI to AX.
	mov di, offset __M+10  ; rp = &_M.m3_ca1[0];
	rep movsb
	xchg di, ax  ; Restore DI from AX. AX := junk.
callm3skip:
	pop si  ; Restore.
	jmp _callx
ENDIF

; int creat(const char *_path, mode_t _mode);
IFDEF U_creat
PUBLIC _creat
_creat:
IFDEF __ELKS__
	mov al, 5  ; SYS_open.
	mov bx, sp
	;mov dx, 666q
	mov dx, [bx+4]  ; _mode.
	mov cx, 01101o  ; ELKS O_CREAT == 0100q, O_TRUNC == 01000o. O_WRONLY == 1.
	jmp sesys1b
ELSE  ; __ELKS__
	mov byte ptr [__M+2], 8  ; *(char*)&_M.m_type = CREAT;
	; Fall through to callm3arg2.
IFNDEF DO_callm3arg2
DO_callm3arg2 =
ENDIF
ENDIF  ; ELSE __ELKS__
ENDIF
IFNDEF __ELKS__
IFDEF U_chmod
IFNDEF DO_callm3arg2
DO_callm3arg2 =
ENDIF
ENDIF
ENDIF  ; IFNDEF __ELKS__
;
IFDEF DO_callm3arg2
callm3arg2:  ; MINIX.
	mov bx, sp
	mov ax, [bx+4]  ; Argument mode.
	jmp callm3ax  ; _M.m3_i2 = mode.
ENDIF

; int chmod(const char *_path, mode_t _mode);
IFDEF U_chmod
PUBLIC _chmod
_chmod:
; PUBLIC int chmod(_path, _mode)
; _CONST char *_path;
; mode_t _mode;
; {
;   return(callm3(FS, CHMOD, _mode, _path));
; }
IFDEF __ELKS__
	mov al, 15  ; SYS_chmod.
	jmp sesys3
ELSE  ; __ELKS__
	mov byte ptr [__M+2], 15  ; *(char*)&_M.m_type = CHMOD;
	jmp callm3arg2
ENDIF  ; ELSE __ELKS__
ENDIF

; char *remove(const char *_path);
; char *unlink(const char *_path);
;
; Locates final occurrence of c (as unsigned char) in string s.
IFDEF U_remove
PUBLIC _remove
ENDIF
IFDEF U_unlink
PUBLIC _unlink
_unlink:
IFNDEF U_remove
U_remove =
ENDIF
ENDIF
IFDEF U_remove
_remove:
; MINIX PUBLIC int unlink(name)
; _CONST char *name;
; {
;   return(callm3(FS, UNLINK, 0, name));
; }
IFDEF __ELKS__
	mov al, 10  ; SYS_unlink.
	jmp sesys3
ELSE  ; __ELKS__
	mov byte ptr [__M+2], 10  ; *(char*)&_M.m_type = UNLINK;
	jmp callm3
ENDIF  ; ELSE __ELKS__
ENDIF

; int rename(const char *_oldpath, const char *_newpath);
IFDEF U_rename
PUBLIC _rename
_rename:
; MINIX PUBLIC int rename(_oldpath, _newpath)
; _CONST char *_oldpath;
; _CONST char *_newpath;
; {
;   return(callm1(FS, RENAME, strlen(_oldpath) + 1, strlen(_newpath) + 1, 0, (char *) _oldpath, (char *) _newpath, NIL_PTR));
; }
IFDEF __ELKS__
	mov al, 38  ; SYS_rename.
	jmp sesys3  ; TODO(pts): Move it closer to sesys3, to make it a short jump.
ELSE  ; __ELKS__
	mov byte ptr [__M+2], 38  ; *(char*)&_M.m_type = RENAME;
	mov bx, sp
	mov bx, [bx+2]  ; Argument _oldpath.
	mov word ptr [__M+10], bx  ; _M.m1_p1 = (char *) _oldpath;
IFNDEF U_strlen
U_strlen =
ENDIF
	call __strlenbx  ; AX := strlen(_oldpath). Ruins BX, CX, DX (and ES etc.).
	inc ax  ; AX := strlen(_oldpath) + 1.
	mov word ptr [__M+4], ax  ; _M.m1_i1 = strlen(_oldpath) + 1;
	mov bx, sp  ; `call _strlen' above has ruined it.
	mov bx, [bx+4]  ; Argument _newpath.
	mov word ptr [__M+12], bx  ; _M.m1_p2 = (char *) _newpath;
	call __strlenbx  ; AX := strlen(_newpath). Ruins BX, CX, DX (and ES etc.).
	inc ax  ; AX := strlen(_newpath) + 1.
	mov word ptr [__M+6], ax  ;  _M.m1_i2 = strlen(_newpath) + 1;
	jmp _callx
ENDIF  ; ELSE __ELKS__
ENDIF

; int isatty(int fd);
IFDEF U_isatty
PUBLIC _isatty
_isatty:
IFDEF __ELKS__
	mov bx, sp
	mov bx, [bx+2]  ; Argument fd.
	sub sp, 24h  ; ISATTY_TERMIOS_SIZE.  0x24 bytes for ELKS, 0x20 bytes for Minix >=1.7.5.
	mov dx, sp  ; arg3 arg of SYS.ioctl.
	mov ax, 54  ; SYS.ioctl. Also sets AH := 0.
	mov cx, 5401h  ; IOCTL_ELKS.TCGETS.
	int 80h  ;  ELKS syscall.
	cmp ax, -38  ; -ERRNO_ELKS.ENOSYS. ELKS 0.2.0 libc does the same.
	jne isattygot  ; Jumps for ELKS >=1.0.4, maybe it doesn't jump for some earlier versions.
	; ELKS 0.2.0 libc makes isatty(2) return true for ENOSYS if fd < 3. We do a shortcut, and always return true here. TODO(pts): Revise this when open(2) is implemented.
	xor ax, ax  ; We will return true (1) if the syscall is not implemented by the kernel (ENOSYS).
isattygot:
	add sp, 24h  ; ISATTY_TERMIOS_SIZE
ELSE  ; __ELKS__
; MINIX int isatty(fd) int fd; {  /* Minix 1.5--1.7.2. */
;   _M.TTY_REQUEST = 0x7408;  /* TIOCGETP == 0x7408 on Minix 1.5.10. */  /* #define TTY_REQUEST m2_i3 */
;   _M.TTY_LINE = fd;  /* #define TTY_LINE m2_i1 */
;   return(callx(FS, IOCTL) >= 0);  /* FS == 1; IOCTL == 54. */
; }
; MINIX int isatty(fd) int fd; {  /* Minix 1.7.4--2.0.4--3.2.0, merged isatty(...), tcgetattr(...) and ioctl(...) */
;  struct termios dummy;  /* sizeof(struct termios) == 36 == 0x24 on i386, == 32 == 0x20 on i86. */
;  m.TTY_REQUEST = (unsigned) (0x80245408L & ~(unsigned) 0);  /* TCGETS == (int) 0x80245408L on Minix 2.0.4 */  /* #define TTY_REQUEST COUNT */  /* #define COUNT m2_i3 */
;  m.TTY_LINE = fd;  /* #define TTY_LINE DEVICE */  /* #define DEVICE m2_i1 */
;  m.ADDRESS = (char *) &dummy;  /* #define ADDRESS m2_p1 */
;  return((callx(FS, IOCTL) >= 0);  /* FS == 1; IOCTL == 54. */  /* Actually, Minix does (...) == 0. */
; }
; MINIX int isatty(fd) int fd; {  /* Our implementation below, compatible with Minix 1.5--2.0.4--3.2.0. */
;   char dummy[sizeof(int) == 2 ? 32 : 36];  /* struct termios dummy; */  /* For compatibility with Minix 1.7.4--2.0.4--3.2.0. */
;   _M.TTY_REQUEST = 0x7408;  /* TIOCGETP; */
;   _M.TTY_LINE = fd;
;   if (callx(FS, IOCTL) >= 0) goto found_tty;  /* Minix 1.5--1.7.2. */
;   _M.TTY_REQUEST = (unsigned) (0x80245408L & ~(unsigned) 0);  /* TCGETS. */
;   _M.TTY_LINE = fd;
;   _M.ADDRESS = dummy;
;   if (callx(FS, IOCTL) < 0) return 0;  /* Minix 1.7.4--2.0.4--3.2.0. */
;  found_tty:
;   return(1);
; }
	; First try: Minix 1.5--1.7.2.
	mov byte ptr [__M+2], 54  ; *(char*)&_M.m_type = IOCTL;
	mov word ptr [__M+8], 7408h  ; _M.TTY_REQUEST = Minix_1_5_TIOCGETP;
	mov bx, sp
	mov ax, [bx+2]  ; Argument fd.
	mov word ptr [__M+4], ax  ; _M.TTY_LINE = fd;
	call _callx  ; if (callx() >= 0) goto isattydone;
	test ax, ax
	jns isattydone  ; Jump iff found a TTY.
	; Not found a TTY for the first try. Second try: Minix 1.7.4--2.0.4--3.2.0.
	mov word ptr [__M+8], 5408h  ; _M.TTY_REQUEST = Minix_1_7_2_TIOCGETP;
	mov bx, sp
	mov ax, [bx+2]  ; Argument fd.
	mov word ptr [__M+4], ax  ; _M.TTY_LINE = fd;
	sub sp, 32  ; struct termios &dummy;
	mov word ptr [__M+18], sp  ; _M.ADDRESS = &dummy.  ; m2_p1.
	call _callx  ; if (callx() >= 0) goto isattydone;
	add sp, 32  ; Pop the dummy.
isattydone:  ; return callx() >= 0;
ENDIF  ; ELSE __ELKS__
	; Now convert result AX: negative to 0, everything else to 1.
	; This would be 1 byte longer.
	;test ax, ax
	;mov ax, 1
	;jns isattyret
	;dec ax  ; AX := 0.
	rol ax, 1
	not ax
	and ax, 1
;isattyret:
	ret
ENDIF

; off_t lseek(int fd, off_t offset, int whence);
IFDEF U_lseek
PUBLIC _lseek
_lseek:
; MINIX PUBLIC off_t lseek(fd, offset, whence)
; int fd;
; off_t offset;
; int whence;
; {
;   int k;
;   *(char*)&_M.m_type = LSEEK;
;   _M.m2_i1 = fd;
;   _M.m2_l1 = offset;
;   _M.m2_i2 = whence;
;   if ((k = callx()) != 0) return((off_t) k);
;   return((off_t) _M.m2_l1);
; }
IFDEF __ELKS__
	mov ax, 19  ; SYS_lseek.
	mov bx, sp
	mov dx, [bx+8]  ; Argument whence.
	lea cx, [bx+4]  ; Pointer to argument offset.
	mov bx, [bx+2]  ; Argument 1 (fd of read(...) and write(...)).
	int 80h  ; ELKS syscall.
	test ax, ax
	js lseekerr
	mov bx, sp
	mov dx, [bx+6]  ; The ELKS kernel has modifier the argument offset in place. This is the high word.
	mov ax, [bx+4]  ; The ELKS kernel has modifier the argument offset in place. This is the low  word.
	jmp lseekret
lseekerr:
IFDEF U_errno
	neg ax
	mov [_errno], ax
ENDIF
	mov ax, -1  ; Now we could set errno to -AX (for both Minix and ELKS).
	cwd  ; DX := AX (== -1).
lseekret:
	ret
ELSE  ; __ELKS__
	mov bx, si  ; Save SI to BX.
	mov si, sp
	lodsw  ; SI += 2; AX := junk.
	mov byte ptr [__M+2], 19  ; *(char*)&_M.m_type = LSEEK;
	lodsw  ; Argument fd.
	mov word ptr [__M+4], ax
	lodsw  ; Low  word of argument offset.
	mov word ptr [__M+10], ax
	lodsw  ; High word of argument offset.
	mov word ptr [__M+12], ax
	lodsw  ; Argument whence.
	mov si, bx  ; Restore SI from BX.
	mov word ptr [__M+6], ax
	call _callx
	test ax, ax  ; if ((k = callx()) != 0)
	jz lseekcopyofs
	cwd  ; return((off_t) k);
	jmp lseekret
lseekcopyofs:
	mov ax, word ptr [__M+10]
	mov dx, word ptr [__M+12]  ; return((off_t) _M.m2_l1);
lseekret:
	ret  ; Return result in DX:AX.
ENDIF  ; ELSE __ELKS__
ENDIF

; int fstat(int _fd, struct stat *_statbuf);
IFDEF U_fstat
IFDEF __ELKS__  ; For Minix, it is defined above.
PUBLIC _fstat
_fstat:
	mov ax, 28  ; SYS_fstat.
	; Fall through to DO_commonstat.
IFNDEF DO_commonstat
DO_commonstat =
ENDIF
ENDIF  ; IFDEF __ELKS__
ENDIF
IFDEF __ELKS__
IFDEF U_stat
IFNDEF DO_commonstat
DO_commonstat =
ENDIF
ENDIF
IFDEF U_lstat
IFNDEF DO_commonstat
DO_commonstat =
ENDIF
ENDIF
ENDIF  ; IFDEF __ELKS__
;
IFDEF DO_commonstat  ; ELKS.
commonstat:
	; The libc caller should pass a 32-bytes struct stat with 32-bit
	; st_ino here. This call (commonstat) will convert an in-kernel
	; 16-bit st_ino to 32 bits if needed. ELKS 0.2.0
	;
	; ELKS 0.2.0 had a 16-bit st_ino, ELKS 0.2.1--0.3.0--0.4.0-- had it
	; configurable (with CONFIG_32BIT_INODES), and ELKS 0.8.1 has 32-bit
	; only. Here is the struct stat layout:
	;
	; offset  old       new
	; 0       st_dev    st_dev
	; 2       st_ino    low  word of st_ino
	; 4       st_mode   high word of st_ino
	; 6       st_nlink  st_mode,  >=1000h
	; 8       st_uid    st_nlink, >=1
	;
	; We detect old struct stat by word_at_6<1000h, which is correct
	; most of time, except it fails to detect an old ELKS kernel with a
	; Minix (v2 or v3) filesystem with a file with at least 1000h links,
	; which is unlikely. Alternatively, we could parse the string
	; returned by uname(...).
	mov bx, sp
	mov cx, [bx+4]  ; Argument _statbuf.
	mov bx, [bx+2]  ; Argument _fd or _path.
	int 80h  ; ELKS syscall.
	test ax, ax
	js commonstaterr
	mov bx, sp
	mov bx, [bx+4]  ; Argument _statbuf.
	cmp byte ptr [bx+7], 10h
	jae commonstatret  ;  Jump if new kernel.
	push si  ; Save.
	push di  ; Save.
	lea si, [bx+28]
	lea di, [bx+30]
	mov cx, 13
	std
	rep movsw  ; Make room for the 32-bit st_ino by copying everthing beyond it.
	cld
	pop di  ; Restore.
	pop si  ; Restore.
	mov [bx+4], cx  ; Zero-extend 16-bit st_ino (word ptr [bx+2]) to 32 bis. (CX == 0.)
	jmp commonstatret
commonstaterr:
IFDEF U_errno  ; TODO(pts): `jmp sesyserr', or even `js sesyserr' if close enough.
	neg ax
	mov [_errno], ax
ENDIF
	mov ax, -1  ; Now we could set errno to -AX (for both Minix and ELKS).
commonstatret:
	ret
ENDIF

; int stat(const char *_path, struct stat *_statbuf);
IFDEF U_stat
PUBLIC _stat
_stat:
; MINIX PUBLIC int stat(_path, _statbuf)
; _CONST char *_path;
; struct stat *_statbuf;
; {
;   return(callm1(FS, STAT, strlen(_path) + 1, 0, 0, (char *) _path, (char *) _statbuf, NIL_PTR));
; }
IFDEF __ELKS__
	mov ax, 18  ; SYS_stat.
	jmp commonstat
ELSE  ; __ELKS__
	mov byte ptr [__M+2], 18  ; *(char*)&_M.m_type = STAT;
	mov bx, sp
	mov ax, [bx+4]  ; AX := _statbuf.
	mov word ptr [__M+12], ax  ; _M.m1_p2 = (char *) _statbuf;
	mov bx, [bx+2]  ; BX := _path.
	mov word ptr [__M+10], bx  ; _M.m1_p1 = (char *) _path;
IFNDEF U_strlen
U_strlen =
ENDIF
	call __strlenbx  ; AX := strlen(_path). Ruins BX, CX, DX (and ES etc.).
	inc ax  ; AX := strlen(_path) + 1.
	mov word ptr [__M+4], ax  ; _M.m1_i1 = strlen(_path) + 1;
	jmp _callx
ENDIF  ; ELSE __ELKS__
ENDIF

; int lstat(const char *_path, struct stat *_statbuf);
IFDEF U_stat
IFDEF __ELKS__  ; There is no lstat system call on Minix 1.15.0.
PUBLIC _lstat
_lstat:
	mov ax, 57  ; SYS_lstat.
	jmp commonstat
ENDIF  ; IFDEF __ELKS__
ENDIF

; char *sbrk(int incr);
IFDEF U_sbrk
PUBLIC _sbrk
_sbrk:
; extern char *brksize;
; MINIX PUBLIC char *sbrk(incr) int incr; {
;   char *newsize, *oldsize;
;   oldsize = brksize;
;   newsize = brksize + incr;
;   if (incr > 0 && newsize < oldsize || incr < 0 && newsize > oldsize)	return((char *) -1);
;   if (brk(newsize) == 0) return(oldsize);  /* This changes brksize on success. */
;   return((char *) -1);
; }
IFDEF __ELKS__  ; Based on dev86-0.16.21/libc/bcc/heap.c .
	mov   bx, sp
	mov   ax, [bx+2]      ; Fetch the requested value
	test  ax, ax
	jnz   sbrkchanged
	mov   ax, [_brksize]  ; Simple one,  read current - can`t fail.
	ret
sbrkchanged:
	js    go_down
	add   ax, [_brksize]  ; Going up;
	jc    sbrknomem
	sub   bx, 511         ; Safety space 512 bytes
	cmp   bx, ax          ; Too close ?
	jb    sbrknomem
sbrkok:
	push  ax
	;call  ___brk         ; Tell the kernel
	xchg bx, ax
	mov ax, 17            ; SYS_brk.
	int 80h               ; ELKS syscall.
	pop   bx              ; ASSUME ___brk doesn`t alter stack;
	test ax, ax
	jz sbrkok2
	xor ax, bx            ; elksemu indicates success like this: AX == BX.
	jnz sbrknomem         ; Ugh; kernel didn`t like the idea;
sbrkok2:
	xchg [_brksize], ax   ; Save away new val. Before this, AX was 0.
	ret                   ; Return AX == 0 to indicate success.
go_down:
	add   ax, [_brksize]
	jnc   sbrknomem
	cmp   ax, offset __end
	jae   sbrkok
sbrknomem:
	;mov   ax, 12          ; This should be ENOMEM not a magic.
	;mov   [_errno], ax
	mov   ax, -1
	ret
ELSE  ; __ELKS__
	push si  ; Save.
	mov bx, sp
	mov bx, word ptr [bx+4]  ; Argument incr.
	mov si, [_brksize]  ; SI (oldsize) := _brksize.
	test bx, bx  ; incr.
	lea bx, [si+bx]  ; BX (newsize) := SI (_brksize, oldsize) + incr (BX). It doesn't change the flags.
	;jz sbrkinrange  ; The logic is correct even without this.
	js sbrknegative
	cmp bx, si  ; BX (newsize) < SI (oldsize).
	jb sbrkerror
	jmp sbrkinrange
sbrknegative:
	cmp bx, si  ; BX (newsize) > SI (oldsize).
	ja sbrkerror
sbrkinrange:
	push bx  ; newsize.
IFNDEF U_brk
U_brk =
ENDIF
	call _brk  ; Ruins BX, CX, DX (and ES etc.). It's important that it keeps SI (== oldsize).
	pop bx  ; Clean up argument of _brk above.
	xchg ax, si  ; AX := oldsize; SI := result of brk(newsize).
	test si, si  ; if (brk(newsize) == 0)  /* This changes brksize on success. */
	jz sbrkret  ; return(oldsize);
sbrkerror:
	mov ax, -1
sbrkret:
	pop si  ; Restore.
	ret
ENDIF  ; ELSE __ELKS__
ENDIF

; int brk(char *addr);
;
; Sets the break address (end of heap) to the desired value. Returns NULL on success.
IFDEF U_brk
PUBLIC _brk
_brk:
; MINIX PUBLIC int brk(addr) char *addr; {
;   *(char*)&_M.m_type = BRK;
;   _M.m1_p1 = addr;
;   if (callx() == 0) {
;     brksize = _M.m2_p1;
;     return 0;  /* In Minix 1.5.10, the original return type was (char*). */
;   } ELSE {
;     return -1;
;   }
; }
IFDEF __ELKS__  ; Based on dev86-0.16.21/libc/bcc/heap.c .
	mov   bx, sp
	mov   ax, [bx+2]      ; Fetch the requested value
	sub   bx, 512         ; Safety space 512 bytes
	cmp   bx, ax          ; Too close ?
	jb    brknomem
	cmp   ax, offset __end
	jae   brkok1
brknomem:
	;mov   ax, 12          ; This should be ENOMEM not a magic.
	;mov   [_errno], ax
	mov   ax, -1
	ret
brkok1:
	push  ax
	;call  ___brk         ; Tell the kernel
	xchg bx, ax
	mov ax, 17            ; SYS_brk.
	int 80h               ; ELKS syscall.
	pop   bx              ; ASSUME ___brk doesn`t alter stack;
	test ax, ax
	jz brkok2
	xor ax, bx            ; elksemu indicates success like this: AX == BX.
	jnz brknomem          ; Ugh; kernel didn`t like the idea;
brkok2:
	mov   [_brksize], bx  ; Save away new val
	ret                   ; Return AX == 0 to indicate success.
ELSE  ; __ELKS__
	mov byte ptr [__M+2], 17  ; *(char*)&_M.m_type = BRK;
	mov bx, sp
	mov bx, [bx+2]  ; Argument addr.
	mov word ptr [__M+10], bx
	call _callx
	test ax, ax
	jnz brkerror
	mov bx, word ptr [__M+18]  ; _M.m2_p1.
	mov [_brksize], bx  ; brksize = _M.m2_p1;
	jmp brkret
brkerror:
	mov ax, -1  ; return((char *) -1);
brkret:
	ret
ENDIF  ; ELSE __ELKS__
ENDIF

; See also the implementation of the signal libc function.
;
; The ELKS kernel calls ___system_signal like this: it pushes the signal
; number (signum); if it is a new kernel (such as ELKS 0.7.0, or maybe a bit
; order), it pushes the return segment; it push the return offset; it jumps
; to ___system_signal. (It doesn't push FLAGS.) (It doesn't save any
; registers.) Upon return, the kernel expects that ___system_signal pops
; everything above.
IFDEF U___system_signal
PUBLIC ___system_signal
___system_signal:
IFDEF __ELKS__
	pushf
	push ax
	push bx
	push cx
	push dx
	push si
	push di
	push bp
	push es
	mov bx, sp
	mov ax, cs
	cmp [bx+20], ax  ; This is a best effort guess to decide whether the (new) kernel has pushed CS. !! TODO(pts): Do it for 100% by checking for EINVAL in SYS_signal.
	pushf
	jne ssigold
	inc bx
	inc bx  ; Skip over the CS pushed by the new kernel.
ssigold:
	mov bx, [bx+20]  ; BX := signum.
	push bx  ; Argument signum of the signal handler.
	add bx, bx
	; TODO(pts): Do a bounds-check (1 <= BX < NSIG) on BX.
	call [bx+___sigtable-2]  ; Offset by 2 because no entry for signal 0.
	pop cx  ; Clean up signum argument of `call bx' above.
	popf  ; Get the result of `cmp [bx+20], ax' above.
	pop es
	pop bp
	pop di
	pop si
	pop dx
	pop cx
	pop bx
	pop ax
	jne ssigretold
	popf
	retf 2  ; Get rid of the signum too.
ssigretold:
	popf
	ret 2  ; Get rid of the signum too.
ELSE  ; __ELKS__
	push ax  ; after interrupt, save all regs
	push bx
	push cx
	push dx
	push si
	push di
	push bp
	push ds
	push es
	mov bx, sp
	mov bx, [bx+18]         ; bx = signal number
	mov ax, bx              ; ax = signal number
	dec bx                  ; __sigtable[0] is for sig 1
	add bx, bx              ; pointers are two bytes on 8088
	mov bx, [bx+___sigtable]  ; bx = address of routine to call
	push word ptr [__M+2]   ; push status of last system call; mtype
	push ax                 ; func called with signal number as arg
	call bx
	pop ax  ; get signal number off stack
	pop word ptr [__M+2]  ; restore status of previous system call; mtype
	pop es  ; signal handling finished
	pop ds
	pop bp
	pop di
	pop si
	pop dx
	pop cx
	pop bx
	pop ax
	add sp, 2  ; remove signal number from stack
	iret
ENDIF  ; __ELKS__
ENDIF

; void (*signal((int _sig, void (*_func)(int))))(int);
IFDEF U_signal
PUBLIC _signal
_signal:
IFDEF __ELKS__
; It is assumed the kernel will never give us a signal we haven't
; _explicitly_ asked for.
;
; The kernel need only save space for _one_ function pointer
; (to __system_signal) and must deal with SIG_DFL and SIG_IGN
; in kernel space.
;
; When a signal is required, the kernel must set all the registers as if
; returning from a interrupt normally then push the number of the signal
; to be generated, push the current pc value, then set the pc to the
; address of the __system_signal function.
;
; ELKS void (*signal(_sig, _handler))()
; int _sig;
; void (*_handler)(int);
; {
;   void (*old_handler)(int);
;   int rv;
;   if( _sig < 1 || _sig >= NSIG ) { errno = EINVAL; return SIG_ERR; }
;   if( _handler == SIG_DFL || _handler == SIG_IGN )
;     rv = syscall2(SYS_signal, _sig, (int) _handler);
;   else
;     rv = syscall2(SYS_signal, _sig, (int) __system_signal);
;   if( rv < 0 ) return SIG_ERR;
;   old_handler = __sigtable[_sig-1];
;   __sigtable[_sig-1] = _handler;
;   return rv == 0 ? (void(*)(int)) SIG_DFL : rv == 1 ? (void(*)(int)) SIG_IGN : old_handler;
; }
ELSE  ; __ELKS__
; /* This is for educational purposes. The ELKS variant is used on Minix as well. */
; void (*signal(_sig, _handler))()
; int _sig;
; void (*_handler)(int);
; {
;   int r;
;   void (*old) ();
;   old = __sigtable[_sig - 1];
;   _M.m6_i1 = _sig;
;   if (_handler == SIG_IGN || _handler == SIG_DFL) {
;     /* Keep old signal handler until it is completely de-installed */
;     _M.m6_f1 = (void (*)())_handler;
;   } else {
;     /* Use new signal handler immediately (old one may not exist) */
;     __sigtable[_sig - 1] = _handler;
;     _M.m6_f1 = __system_signal;
;   }
;   r = callx(MM, SIGNAL);
;   if (r < 0) {
;     __sigtable[_sig - 1] = old;  /* undo any pre-installation */
;     return((void (*) ()) r);
;   }
;   __sigtable[_sig - 1] = _handler;  /* redo any pre-installation */
;   if (r == 1) return(SIG_IGN);
;   return(old);
; }
ENDIF  ; __ELKS__
	push si  ; Save.
	push bp  ; Save.
	mov bp, sp
	mov si, [bp+6]  ; Argument _sig.
	mov bp, [bp+8]  ; Argument _handler.
	cmp si, 1
	jl signal5
	cmp si, NSIG  ; NSIG.
	jl signal7
signal5:
IFDEF U_errno
	mov word ptr [_errno], 22  ; EINVAL.
ENDIF
signal6:
	mov ax, -1  ; SIG_ERR.
	jmp signaldone
signal7:
IFDEF __ELKS__
	mov dx, cs  ; Segment of ___system_signal, for new ELKS kernels (such as 0.7.0, or a bit earlier).
ENDIF  ; __ELKS__
	mov cx, offset ___system_signal  ; Argument 2 of SYS_signal.
	cmp bp, 1  ; SIG_IGN == 1. SIG_DFL == 0.
	ja signal9
IFDEF __ELKS__
	xor dx, dx  ; High word of _handler, for new ELKS kernels (such as 0.7.0, or a bit earlier).
ENDIF  ; __ELKS__
	mov cx, bp  ; Argument 2 of SYS_signal.
signal9:
IFDEF __ELKS__
	mov bx, si  ; Argument 1 of SYS_signal: _sig.
	mov al, 48  ; SYS_signal.
	call sesys
ELSE  ; __ELKS__
	mov byte ptr [__M+2], 48  ; *(char*)&_M.m_type = SIGNAL;
	mov word ptr [__M+4], si  ; _M.m6_i1 = _sig;
	mov word ptr [__M+14], cx  ; _M.m6_f1.
	xor ax, ax  ; MM.
	call callxmmfs
ENDIF  ; __ELKS__
	test ax, ax
	js signal6
	mov bx, offset ___sigtable-2
	add bx, si
	add bx, si
	xchg [bx], bp  ; old_handler = __sigtable[_sig-1];  __sigtable[_sig-1] = _handler;
	cmp ax, 1  ; SIG_IGN == 1. SIG_DFL == 0.
	jbe signaldone
	xchg ax, bp  ; AX := old_handler; BP := junk.
signaldone:
	pop bp  ; Restore.
	pop si  ; Restore.
	ret
ENDIF

; int execv(char *_path, char *_argv[]);
IFDEF U_execv
PUBLIC _execv
_execv:
; int execv(_path, _argv)
; char *_path;
; char **_argv;
; {
;   return execve(_path, _argv, environ);
; }
IFNDEF U_execve
U_execve =
ENDIF
	mov bx, sp
	push [_environ]
	push word ptr [bx+4]
	push word ptr [bx+2]
	call _execve
	add sp, 6  ; Clean up arguments of _execve above.
	ret
ENDIF

; int execve(char *_path, char *_argv[], char *_envp[]);
IFDEF U_execve
PUBLIC _execve
_execve:
IFDEF __ELKS__
; int execve(_path, _argv, _envp)
; char *_path;
; char *_argv[];
; char *_envp[];
; {
;   char **p;
;   int _argv_len=0, _argv_count=0;
;   int _envp_len=0, _envp_count=0;
;   int stack_bytes;
;   unsigned short * pip;
;   char * pcp, * stk_ptr, *baseoff;
;   int rv;
;   unsigned l;
;   for(p=_argv; p && *p && _argv_len >= 0; p++) {
;     _argv_count++; _argv_len += strlen(*p)+1;
;   }
;   for(p=_envp; p && *p && _envp_len >= 0; p++) {
;     _envp_count++; _envp_len += strlen(*p)+1;
;   }
;   stack_bytes = 2 + _argv_count * 2 + 2 + _argv_len + _envp_count * 2 + 2 + _envp_len;
;   if( _argv_len < 0 || _envp_len < 0 || stack_bytes <= 0 || (int)(stk_ptr = (char*)sbrk(stack_bytes)) == -1) {
;     errno = ENOMEM;
;     return -1;
;   }
;   pip=(unsigned short *) stk_ptr;
;   pcp=stk_ptr+2*(1+_argv_count+1+_envp_count+1);
;   baseoff = stk_ptr;
;   *pip++ = _argv_count;
;   for(p=_argv; p && *p; p++) {
;     *pip++ = pcp-baseoff;
;     l = strlen(*p)+1;
;     memcpy(pcp, *p, l);
;     pcp += l;
;   }
;   *pip++ = 0;
;   for(p=_envp; p && *p; p++) {
;     *pip++ = pcp-baseoff;
;     l = strlen(*p)+1;
;     memcpy(pcp, *p, l);
;     pcp += l;
;   }
;   *pip++ = 0;
;   rv = syscall3(SYS_execve, (int) _path, (int) stk_ptr, stack_bytes);
;   sbrk(-stack_bytes);
;   return rv;
; }
ELSE  ; __ELKS__
; int execve(_path, _argv, _envp)
; char *_path;
; char *_argv[];
; char *_envp[];
; {
;   char **argtop;
;   char **envtop;
;   int nargs;                    /* number of args */
;   int nenvps;                   /* number of environment strings */
;   char *hp, **ap, *p;
;   int i, stackbytes, npointers, overflow, temp;
;   char *stack;
;   /* Count the argument pointers and environment pointers. */
;   for (argtop = _argv; *argtop != (char *) 0; ) argtop++;
;   for (envtop = envp; *envtop != (char *) 0; ) envtop++;
;   nargs = argtop - _argv;
;   nenvps = envtop - envp;
;   /* Decide how big a stack is needed. Be paranoid about overflow. */
;   overflow = 0  /* FALSE */;
;   npointers = 1 + nargs + 1 + nenvps + 1;       /* 1's for argc and NULLs */
;   stackbytes = nargs + nenvps;          /* for nulls in strings */
;   if (nargs < 0 || nenvps < 0 || stackbytes < nargs || npointers < stackbytes)
;         overflow = 1  /* TRUE */;
;   for (i = sizeof(char *); i != 0; i--) {
;         temp = stackbytes + npointers;
;         if (temp < stackbytes) overflow = 1  /* TRUE */;
;         stackbytes = temp;
;   }
;   for (i = 0, ap = _argv; i < nargs; i++) {
;         temp = stackbytes + strlen(*ap++);
;         if (temp < stackbytes) overflow = 1  /* TRUE */;
;         stackbytes = temp;
;   }
;   for (i = 0, ap = envp; i < nenvps; i++) {
;         temp = stackbytes + strlen(*ap++);
;         if (temp < stackbytes) overflow = 1  /* TRUE */;
;         stackbytes = temp;
;   }
;   temp = stackbytes + sizeof(char *) - 1;
;   if (temp < stackbytes) overflow = 1  /* TRUE */;
;   stackbytes = (temp / sizeof(char *)) * sizeof(char *);
;   /* Check for overflow before committing sbrk. */
;   if (overflow || stackbytes > ARG_MAX) {
;         errno = ENOMEM;  /* In Minix, this is E2BIG. */
;         return(-1);
;   }
;   /* Allocate the stack. */
;   stack = sbrk(stackbytes);
;   if (stack == (char *) -1) {
;         errno = ENOMEM;  /* In Minix, this is E2BIG. */
;         return(-1);
;   }
;   /* Prepare the stack vector and argc. */
;   ap = (char **) stack;
;   hp = &stack[npointers * sizeof(char *)];
;   *ap++ = (char *) nargs;
;   /* Prepare the argument pointers and strings. */
;   for (i = 0; i < nargs; i++) {
;         *ap++ = (char *) (hp - stack);
;         p = *_argv++;
;         while ((*hp++ = *p++) != 0)
;                 ;
;   }
;   *ap++ = (char *) 0;
;   /* Prepare the environment pointers and strings. */
;   for (i = 0; i < nenvps; i++) {
;         *ap++ = (char *) (hp - stack);
;         p = *envp++;
;         while ((*hp++ = *p++) != 0)
;                 ;
;   }
;   *ap++ = (char *) 0;
;   /* Do the real work. */
;   temp = callm1(MM  /* 0 */, EXEC  /* 59 */, strlen(_path) + 1, stackbytes, 0, _path, stack, 0);
;   sbrk(-stackbytes);
;   return(temp);
; }
ENDIF  ; __ELKS__
	push si
	push di
	push bp
	mov bp, sp
IFNDEF U_strlen
U_strlen =
ENDIF
IFDEF __ELKS__
	sub sp, 10H  ; !! Word -10H[bp] is now unused.
	xor ax, ax
	mov -4[bp], ax  ; !! Fix assembly source style.
	mov -6[bp], ax
	xor di, di
	mov -0aH[bp], ax
	mov si, 0aH[bp]
execve1:
	test si, si
	je execve2
	cmp word ptr [si], 0
	je execve2
	cmp word ptr -4[bp], 0
	jl execve2
	inc word ptr -6[bp]  ; argv_count++;
	mov bx, [si]
	call __strlenbx
	inc ax
	add -4[bp], ax
	inc si
	inc si
	jmp execve1
execve2:
	mov si, 0cH[bp]
execve3:
	test si, si
	je execve4
	mov ax, [si]
	test ax, ax
	je execve4
	test di, di
	jl execve4
	inc word ptr -0aH[bp]  ; envp_count++;
	xchg bx, ax
	call __strlenbx
	inc ax
	add di, ax
	inc si
	inc si
	jmp execve3
execve4:
	mov ax, -6[bp]
	add ax, ax
	add ax, 4
	add ax, -4[bp]
	mov si, -0aH[bp]
	add si, si
	add ax, si
	inc ax
	inc ax
	add ax, di
	mov -8[bp], ax
	cmp word ptr -4[bp], 0
	jl execve5
	test di, di
	jl execve5
	test ax, ax
	jle execve5
	push ax
	call _sbrk
	pop cx  ; Clean up argument of _sbrk above.
	mov cx, ds
	mov es, cx  ; ES := DS. This is needed even with `wcc -r', because the code generated by the OpenWatcom C compiler (wcc) for a switch--case may ruin ES.
	mov di, ax
	mov -0eH[bp], ax
	cmp ax, -1
	jne execve6
execve5:
IFDEF U_errno
	mov word ptr [_errno], 12  ; ENOMEM.
ENDIF
	mov ax, -1
	jmp near ptr execveret
execve6:
	mov ax, -6[bp]
	inc ax
	inc ax
	add ax, -0aH[bp]
	add ax, ax
	inc ax
	inc ax
	mov si, di
	add si, ax
	mov -2[bp], si
	mov -0cH[bp], di
	mov ax, -6[bp]
	stosw
	mov si, 0aH[bp]
execve7:
	test si, si
	je execve8
	cmp word ptr [si], 0
	je execve8
	mov ax, -2[bp]
	sub ax, -0cH[bp]
	stosw
	mov bx, [si]
	call __strlenbx  ; Our _strlen doesn't ruin ES needed by stosw.
	inc ax
	push si  ; Save.
	push di  ; Save.
	xchg cx, ax  ; Argument n.
	mov si, [si]  ; Argument s2.
	mov di, -2[bp]  ; Argument s1.
	rep movsb  ; memcpy(...). Our _memcpy doesn't ruin ES needed by stosw.
	mov -2[bp], di
	pop di  ; Restore.
	pop si  ; Restore.
	inc si
	inc si
	jmp execve7
execve8:
	xor ax, ax
	stosw  ; *pip++ = 0;
	mov si, 0cH[bp]
execve9:  ; TODO(pts): Unify the code in execve7 and execve9.
	test si, si
	je execve10
	cmp word ptr [si], 0
	je execve10
	mov ax, -2[bp]
	sub ax, -0cH[bp]
	stosw
	mov bx, [si]
	call __strlenbx  ; Our _strlen doesn't ruin ES needed by stosw.
	inc ax
	push si  ; Save.
	push di  ; Save.
	xchg cx, ax  ; Argument n.
	mov si, [si]  ; Argument s2.
	mov di, -2[bp]  ; Argument s1.
	mov -2[bp], di
	rep movsb  ; memcpy(...). Our _memcpy doesn't ruin ES needed by stosw.
	pop di  ; Restore.
	pop si  ; Restore.
	inc si
	inc si
	jmp execve9
execve10:
	xor ax, ax
	stosw  ; *pip++ = 0;
	mov al, 11  ; SYS_execve.
	mov bx, 8[bp]
	mov cx, -0eH[bp]
	mov dx, -8[bp]
	call sesys  ; rv = syscall3(SYS_execve, (int) _path, (int) stk_ptr, stack_bytes);
	xchg si, ax  ; SI := AX (rv); AX := junk.
	mov ax, -8[bp]
	neg ax
	push ax
	call _sbrk
	pop cx  ; Clean up argument of _sbrk above.
	mov ax, si
ELSE  ; __ELKS__
	sub sp, 0cH
	mov di, 0aH[bp]
execve1:
	cmp word ptr [di], 0
	je execve2
	inc di
	inc di
	jmp execve1
execve2:
	mov si, 0cH[bp]
execve3:
	mov ax, [si]
	test ax, ax
	je execve4
	inc si
	inc si
	jmp execve3
execve4:
	sub di, 0aH[bp]
	sar di, 1
	mov -4[bp], di
	sub si, 0cH[bp]
	sar si, 1
	mov -0aH[bp], si
	mov -8[bp], ax
	lea ax, 2[di]
	add ax, si
	inc ax
	mov -0cH[bp], ax
	mov ax, di
	add ax, si
	mov -2[bp], ax
	test di, di
	jl execve5
	test si, si
	jl execve5
	cmp ax, di
	jl execve5
	mov ax, -0cH[bp]
	cmp ax, -2[bp]
	jge execve6
execve5:
	mov word ptr -8[bp], 1
execve6:
	mov di, 2
	jmp execve8
execve7:
	mov -2[bp], ax
	dec di
	je execve9
execve8:
	mov ax, -2[bp]
	add ax, -0cH[bp]
	cmp ax, -2[bp]
	jge execve7
	mov word ptr -8[bp], 1
	jmp execve7
execve9:
	mov si, 0aH[bp]
execve10:
	cmp di, -4[bp]
	jge execve12
	mov bx, [si]
	inc si
	inc si
	call __strlenbx
	add ax, -2[bp]
	cmp ax, -2[bp]
	jge execve11
	mov word ptr -8[bp], 1
execve11:
	mov -2[bp], ax
	inc di
	jmp execve10
execve12:
	xor di, di
	mov si, 0cH[bp]
execve13:
	cmp di, -0aH[bp]
	jge execve15
	mov bx, [si]
	inc si
	inc si
	call __strlenbx
	add ax, -2[bp]
	cmp ax, -2[bp]
	jge execve14
	mov word ptr -8[bp], 1
execve14:
	mov -2[bp], ax
	inc di
	jmp execve13
execve15:
	mov ax, -2[bp]
	inc ax
	cmp ax, -2[bp]
	jge execve16
	mov word ptr -8[bp], 1
execve16:
	and ax, -2
	mov -2[bp], ax
	cmp word ptr -8[bp], 0
	jne execve17
	cmp ax, 1000H
	jle execve18
execve17:
IFDEF U_errno
	mov word ptr [_errno], 12  ; ENOMEM.
ENDIF
	mov ax, -1
	jmp near ptr execveret
execve18:
	push ax
	call _sbrk
	pop cx  ; Clean up argument of _sbrk above.
	mov si, ax
	cmp ax, -1
	je execve17
	mov dx, -0cH[bp]
	add dx, dx
	mov cx, ax
	add cx, dx
	mov dx, -4[bp]
	mov [si], dx
	xor di, di
	inc si
	inc si
execve19:
	lea dx, 2[si]
	cmp di, -4[bp]
	jge execve21
	mov bx, cx
	sub bx, ax
	mov [si], bx
	mov bx, 0aH[bp]
	mov bx, [bx]
	mov -6[bp], bx
	mov si, dx
	add word ptr 0aH[bp], 2
execve20:
	mov bx, -6[bp]
	mov dl, byte ptr [bx]
	mov bx, cx
	mov byte ptr [bx], dl
	inc word ptr -6[bp]
	inc cx
	test dl, dl
	jne execve20
	inc di
	jmp execve19
execve21:
	mov word ptr [si], 0
	xor di, di
	mov si, dx
execve22:
	lea dx, 2[si]
	cmp di, -0aH[bp]
	jge execve24
	mov bx, cx
	sub bx, ax
	mov [si], bx
	mov bx, 0cH[bp]
	mov bx, [bx]
	mov -6[bp], bx
	mov si, dx
	add word ptr 0cH[bp], 2
execve23:
	mov bx, -6[bp]
	mov dl, byte ptr [bx]
	mov bx, cx
	mov byte ptr [bx], dl
	inc word ptr -6[bp]
	inc cx
	test dl, dl
	jne execve23
	inc di
	jmp execve22
execve24:
	mov word ptr [__M+12], ax  ; _M.m1_p2 = stack;
	mov ax, 8[bp]  ; path.
	mov word ptr [__M+10], ax  ; _M.m1_p1 = _path;
	mov ax, -2[bp]  ; stackbytes.
	mov word ptr [__M+6], ax  ; _M.m1_i2 = stackbytes.
	mov bx, 8[bp]  ; path.
	call __strlenbx
	inc ax
	mov word ptr [__M+4], ax  ; _M.m1_i1 = strlen(path) + 1.
	mov byte ptr [__M+2], 59  ; *(char*)&_M.m_type = EXEC;
	xor ax, ax  ; MM.
	mov [si], ax  ; *ap++ = (char *) 0;
	call callxmmfs  ; temp = callm1(MM  /* 0 */, EXEC  /* 59 */, strlen(path) + 1, stackbytes, 0, path, stack, 0);
	xchg si, ax
	mov ax, -2[bp]
	neg ax
	push ax
	call _sbrk  ; sbrk(-stackbytes);
	pop cx  ; Clean up argument of _sbrk above.
	xchg ax, si  ;   return(temp);
ENDIF ; __ELKS__
execveret:
	mov sp, bp
	pop bp
	pop di
	pop si
	ret
ENDIF

; --- Environment variables.

; char *getenv(const char *_name);
IFDEF U_getenv
PUBLIC _getenv
_getenv:
	mov dx, ds
	mov es, dx  ; ES := DS. This is needed even with `wcc -r', because the code generated by the OpenWatcom C compiler (wcc) for a switch--case may ruin ES.
	mov cx, si  ; Save SI.
	mov dx, di  ; Save DI.
	mov bx, [_environ]
getenvnextvar:
	mov di, [bx]
	inc bx
	inc bx
	test di, di
	jz getenvdone
	xchg ax, bx  ; Save BX. BX := junk.
	mov bx, sp
	mov si, [bx+2]  ; Argument _name.
	xchg ax, bx  ; Restore BX. AX := junk.
getenvnextbyte:
	lodsb
	cmp al, 0
	je getenvendname
	scasb
	je getenvnextbyte
	jmp short getenvnextvar
getenvendname:
	mov al, '='
	scasb
	jne getenvnextvar
getenvdone:
	xchg ax, di  ; EAX := EDI (pointer to var value); EDI := junk.
	mov di, dx  ; Restore DI.
	mov si, cx  ; Restore SI.
	ret
ENDIF

; --- Memory allocator: malloc(...), free(...), realloc(...).
;
; The code is based on /usr/src/lib/ansi/malloc.c in Minix 1.5.10. A
; modified malloc.c has been compiled with the OpenWatcom v2 C compiler, and
; the disassembly output (wdis -a) has been modified a bit manually.
;
; #define ASSERT_MALLOC(b)  /* empty */
;
; typedef int malloc_intptr_t;  /* This is architecture-dependent. */
;
; #define BRKALIGN      1024
; #define PTRSIZE       sizeof(char *)
; #define Align(x,a)    (((x) + (a - 1)) & ~(malloc_intptr_t)(a - 1))
; #define NextSlot(p)   (* (char **) ((p) - PTRSIZE))
; #define NextFree(p)   (* (char **) (p))
;
; /* A short explanation of the data structure and algorithms.
;  * An area returned by malloc() is called a slot. Each slot
;  * contains the number of bytes requested, but preceeded by
;  * an extra pointer to the next the slot in memory.
;  * '_bottom' and '_top' point to the first/last slot.
;  * More memory is asked for using brk() and appended to top.
;  * The list of free slots is maintained to keep malloc() fast.
;  * '_empty' points the the first free slot. Free slots are
;  * linked together by a pointer at the start of the
;  * user visable part, so just after the next-slot pointer.
;  * Free slots are merged together by free().
;  */
;
; static char *_bottom, *_top, *_empty;
;

IFDEF DO_malloc  ; This is already defined if either malloc(...) or free(...) is needed.
_TEXT ENDS
_BSS SEGMENT
IFDEF U_free
__bottom: dw ?  ; Not exported.
__top:    dw ?  ; Not exported.
__empty:  dw ?  ; Not exported.
ELSE
heapptr: dw ?  ; Not exported.
ENDIF
_BSS ENDS
_TEXT SEGMENT

IFDEF U_free
; static int grow(unsigned len);
;PUBLIC _grow  ; Not exported.
_grow:  ; Calls _brk, _free.
; static int grow(len) unsigned len; {
;   register char *p;
;   ASSERT_MALLOC(NextSlot(_top) == 0);
;   p = (char *) Align((malloc_intptr_t) _top + len, BRKALIGN);
;   if (p < _top || brk(p) != 0) return(0);
;   NextSlot(_top) = p;  NextSlot(p) = 0;
;   free(_top);
;   _top = p;
;   return(1);
; }
	push si
	push bp
	mov bp, sp
	mov si, [__top]
	add si, [bp+6]
	add si, 3ffh
	and si, 0fc00h
	cmp si, [__top]
	jb grow1
	push si
	call _brk
	pop bx  ; Clean up argument of _brk above.
	test ax, ax
	je grow2
grow1:
	xor ax, ax
	jmp growret
grow2:
	mov bx, [__top]
	mov [bx-2], si
	mov [si-2], ax
	push [__top]
	call _free
	pop bx  ; Clean up argument of _brk above.
	mov [__top], si
	mov ax, 1
growret:
	pop bp
	pop si
	ret
ENDIF  ; U_free

; void *malloc(unsigned size);
IFDEF U_malloc
PUBLIC _malloc
_malloc:
ENDIF
IFDEF U_free ; This linked-list implementation calls _sbrk, _grow. Transitively calls _sbrk, _brk, _free.
IFDEF U_malloc_unaligned  ; Same here as regular malloc(...).
PUBLIC _malloc_unaligned
_malloc_unaligned:
ENDIF
; void *malloc(size) unsigned size; {
;   register char *prev, *p, *next, *new;
;   register unsigned len, ntries;
;   if (size == 0) size = PTRSIZE;/* avoid slots less that 2*PTRSIZE */
;   for (ntries = 0; ntries < 2; ntries++) {
;     if ((len = Align(size, PTRSIZE) + PTRSIZE) < 2 * PTRSIZE)
;       return(0);      /* overflow */
;     if (_bottom == 0) {
;       if ((p = sbrk(2 * PTRSIZE)) == (char *) -1) return(0);
;       p = (char *) Align((malloc_intptr_t) p, PTRSIZE);
;       ASSERT_MALLOC(p + PTRSIZE > p); /* sbrk amount stops overflow */
;       p += PTRSIZE;
;       _top = _bottom = p;
;       NextSlot(p) = 0;
;     }
;     for (prev = 0, p = _empty; p != 0; prev = p, p = NextFree(p)) {
;       next = NextSlot(p);
;       new = p + len;  /* easily overflows! */
;       if (new > next || new <= p) continue;   /* too small */
;       if (new + PTRSIZE < next) {     /* too big, so split */
;         /* + PTRSIZE avoids tiny slots on free list */
;         ASSERT_MALLOC(new + PTRSIZE > new);     /* space above next */
;         NextSlot(new) = next;
;         NextSlot(p) = new;
;         NextFree(new) = NextFree(p);
;         NextFree(p) = new;
;       }
;       if (prev) {
;         NextFree(prev) = NextFree(p);
;       } else {
;         _empty = NextFree(p);
;       }
;       return((void *)p);
;     }
;     if (grow(len) == 0) break;
;   }
;   ASSERT_MALLOC(ntries != 2);
;   return((void *)0);
; }
	push si
	push di
	push bp
	mov bp, sp
	push ax
	push ax
	cmp word ptr [bp+8], 0
	jne malloc3
	mov word ptr [bp+8], 2
malloc3:
	mov word ptr [bp-4], 0
	jmp malloc6
malloc4:
	inc word ptr [bp-4]
	cmp word ptr [bp-4], 2
	jb malloc6
malloc5:
	jmp malloc13
malloc6:
	mov ax, [bp+8]
	inc ax
	and al, 0feh
	inc ax
	inc ax
	mov [bp-2], ax
	cmp ax, 4
	jb malloc5
	cmp [__bottom], 0
	jne malloc7
	mov ax, 4
	push ax
	call _sbrk
	pop bx  ; Clean up argument of _brk above.
	cmp ax, -1
	je malloc13
	inc ax
	and al, 0feh
	mov bx, ax
	inc bx
	inc bx
	mov [__bottom], bx
	mov [__top], bx
	mov word ptr [bx-2], 0
malloc7:
	xor di, di
	mov bx, [__empty]
malloc8:
	test bx, bx
	je malloc12
	mov ax, [bx-2]
	mov si, [bp-2]
	add si, bx
	cmp si, ax
	ja malloc11
	cmp si, bx
	jbe malloc11
	lea dx, [si+2]
	cmp dx, ax
	jae malloc9
	mov [si-2], ax
	mov [bx-2], si
	mov ax, [bx]
	mov [si], ax
	mov [bx], si
malloc9:
	test di, di
	je malloc10
	mov ax, [bx]
	mov [di], ax
	jmp malloc14
malloc10:
	mov ax, [bx]
	mov [__empty], ax
	jmp malloc14
malloc11:
	mov di, bx
	mov bx, [bx]
	jmp malloc8
malloc12:
	push [bp-2]
	call _grow
	pop bx  ; Clean up argument of _brk above.
	test ax, ax
	je malloc13
	jmp malloc4
malloc13:
	xor bx, bx
malloc14:
	mov ax, bx
mallocretsp:
	mov sp, bp
mallocret:
	pop bp
	pop di
	pop si
	ret
ELSE  ; U_free. This is the (simple) counting implementation of malloc(...). !! TODO(pts): Add malloc_unaligned.
; void *malloc(unsigned size) {  /* Simple unaligned malloc. */
;   char *result, *heapptr_tmp;
;   if (!heapptr) maxheap();  /* This is for Minix and ELKS only. On more modern systems, it would greedily allocate too much memory. */
;   heapptr_tmp = (size <= 1) ? heapptr : (char *) (((unsigned) heapptr + 1) & ~(unsigned) 1);  /* This never overflows, the kernel doesn't give us this much a_bss. */
;   if (brksize - heapptr_tmp < size) return (void *) 0;  /* Out of memory. */
;   result = heapptr_tmp;
;   heapptr += size;
;   return (void *) result;
; }
IFNDEF U_malloc
PUBLIC _malloc_unaligned
_malloc_unaligned:
ENDIF
malloccntupd:
	mov ax, [heapptr]
	test ax, ax
	jz maxheap  ; It will jump back to malloccntupd above.
	mov bx, sp
	mov bx, [bx+2]  ; Argument size.
IFDEF U_malloc
	cmp bx, 1
	jbe malloccntafteralign
	inc ax
	and al, -2  ; Align DI (heapptr) to a multiple of 2.
malloccntafteralign:
ENDIF
	mov dx, [_brksize]
	sub dx, ax
	cmp dx, bx
	jae malloccnt59
	xor ax, ax  ; return (void *) 0;
	ret
malloccnt59:
	add bx, ax
	mov [heapptr], bx
	ret

IFDEF U_malloc
IFDEF U_malloc_unaligned
PUBLIC _malloc_unaligned
_malloc_unaligned:
	mov ax, [heapptr]
	test ax, ax
	jz maxheap  ; It will jump back to the malloccntupd in the aligned malloc above. That's suboptimal, but fine.
	mov bx, sp
	mov bx, [bx+2]  ; Argument size.
	jmp short malloccntafteralign
ENDIF
ENDIF

maxheap:
; void maxheap() {  /* Increases brksize to the maximum, and sets heapptr = brksize. */
;   unsigned a, m, b;
;   a = (unsigned) (heapptr = brksize);
;   for (b = 1; b <= a && b != 0; b <<= 1) {}
;   if (!b) --b;  /* Decrease on power-of-2 overflow to 0. */
;   while (!brk((char *) b)) {
;     b <<= 1;
;     if (!b) --b;  /* Decrease on power-of-2 overflow to 0. */
;   }
;   for (;;) {  /* Use binary search to find the end of maximal heap. */
;     /* Now `a' bytes are available, and `b' bytes are not available, and `a < b'. */
;     if ((m = a + ((b - a) >> 1)) == a) break;
;     if (brk((char *) m)) {
;       b = m;
;     } else {
;       a = m;
;     }
;   }
;   brksize = (char *) a;  /* End of maximal heap. */
; }
	push si
	push di
	mov ax, [_brksize]
	mov [heapptr], ax
	mov di, ax
	mov si, 1
	cmp ax, si
	jb maxheap49
maxheap48:
	test si, si
	je maxheap49
	shl si, 1
	cmp si, di
	jbe maxheap48
maxheap49:
	test si, si
	je maxheap52
maxheap50:
	push si
	call _brk
	pop cx  ; Clean up argument of _brk above.
	test ax, ax
	je maxheap53
maxheap51:
	mov ax, si
	sub ax, di
	mov dx, di
	shr ax, 1
	add dx, ax
	mov cx, dx
	cmp di, dx
	je maxheap55
	push cx  ; Save CX (m).
	push dx
	call _brk
	pop cx  ; Clean up argument of _brk above.
	pop cx  ; Restore CX (m).
	test ax, ax
	je maxheap54
	mov si, cx
	jmp maxheap51
maxheap52:
	dec si
	jmp maxheap50
maxheap53:
	shl si, 1
	test si, si
	jne maxheap50
	dec si
	jmp maxheap50
maxheap54:
	mov di, cx
	jmp maxheap51
maxheap55:
	mov [_brksize], dx  ; !! TODO(pts): Didn't brk(...) set it already?
	pop di
	pop si
	jmp short malloccntupd
ENDIF
ENDIF  ; U_malloc

; void free(void *pfix);
IFDEF U_free
PUBLIC _free
_free:
IFDEF U_malloc  ; This linked-list implementation doesn't call any of _grow, _malloc, _realloc, _memcpy, _brk, _sbrk.
; void free(pfix) void *pfix; {
;   register char *prev, *next;
;   char *p = (char *) pfix;
;   if (!pfix) return;  /* This is a portability improvement by pts. */
;   ASSERT_MALLOC(NextSlot(p) > p);
;   for (prev = 0, next = _empty; next != 0; prev = next, next = NextFree(next)) {
;     if (p < next) break;
;   }
;   NextFree(p) = next;
;   if (prev) {
;     NextFree(prev) = p;
;   } else {
;     _empty = p;
;   }
;   if (next) {
;     ASSERT_MALLOC(NextSlot(p) <= next);
;     if (NextSlot(p) == next) {      /* merge p and next */
;       NextSlot(p) = NextSlot(next);  NextFree(p) = NextFree(next);
;     }
;   }
;   if (prev) {
;     ASSERT_MALLOC(NextSlot(prev) <= p);
;     if (NextSlot(prev) == p) {      /* merge prev and p */
;       NextSlot(prev) = NextSlot(p);  NextFree(prev) = NextFree(p);
;     }
;   }
; }
	push si
	push di
	push bp
	mov bp, sp
	mov bx, [bp+8]  ; Argument pfix.
	test bx, bx
	jz mallocret  ; if (!pfix) return;
	xor di, di
	mov si, [__empty]
free27:
	test si, si
	je free28
	cmp bx, si
	jb free28
	mov di, si
	mov si, [si]
	jmp free27
free28:
	mov [bx], si
	test di, di
	je free29
	mov [di], bx
	jmp free30
free29:
	mov [__empty], bx
free30:
	test si, si
	je free31
	cmp si, [bx-2]
	jne free31
	mov ax, [si-2]
	mov [bx-2], ax
	mov ax, [si]
	mov [bx], ax
free31:
	test di, di
	je mallocret
	cmp bx, [di-2]
	jne mallocret
	mov ax, [bx-2]
	mov [di-2], ax
	mov bx, [bx]
	mov [di], bx
	jmp short mallocret
ELSE  ; U_malloc
	ret  ; If malloc(...) is never used, then free(...) is a no-op.
ENDIF  ; U_malloc
ENDIF  ; U_free

; void *realloc(void *oldfix, unsigned size);
IFDEF U_realloc
PUBLIC _realloc
_realloc:  ; Calls _free, _malloc, _memcpy.
; void *realloc(oldfix, size)
; void *oldfix;
; unsigned size;
; {
;   register char *prev, *p, *next, *new;
;   register unsigned len, n;
;   char *old = (char *) oldfix;
;   if (!oldfix) return malloc(m);  /* This is a portability improvement by pts. */
;   if (size > ~(unsigned) (2 * PTRSIZE) + 1) return(0);
;   len = Align(size, PTRSIZE) + PTRSIZE;
;   next = NextSlot(old);
;   n = (int) (next - old);       /* old length */
;   /* Extend old if there is any free space just behind it */
;   for (prev = 0, p = _empty; p != 0; prev = p, p = NextFree(p)) {
;     if (p > next) break;
;     if (p == next) {        /* 'next' is a free slot: merge */
;       NextSlot(old) = NextSlot(p);
;       if (prev) {
;               NextFree(prev) = NextFree(p);
;       } else {
;               _empty = NextFree(p);
;       }
;       next = NextSlot(old);
;       break;
;     }
;   }
;   new = old + len;              /* easily overflows! */
;   /* Can we use the old, possibly extended slot? */
;   if (new <= next && new >= old) {      /* it does fit */
;     if (new + PTRSIZE < next) {     /* too big, so split */
;       /* + PTRSIZE avoids tiny slots on free list */
;       ASSERT_MALLOC(new + PTRSIZE > new);
;       NextSlot(new) = next;
;       NextSlot(old) = new;
;       free(new);
;     }
;     return((void *)old);
;   }
;   if ((new = (char *)malloc(size)) == (char*) 0)  /* it didn't fit */
;     return((void *) 0);
;   memcpy(new, old, (size_t)n);          /* n < size */
;   free(old);
;   return((void *)new);
; }
	push si
	push di
	push bp
	mov bp, sp
	push ax
	mov bx, [bp+8]  ; Argument oldfix.
	mov ax, [bp+0ah]  ; Argument size.
	test bx, bx
	jnz reallocnzp
	push ax
	call _malloc  ; if (!oldfix) return malloc(m);
	;pop bx  ; Clean up argument of _malloc above. Not needed, mallocretsp cleans it up.
	jmp mallocretsp
reallocnzp:
	mov si, bx
	cmp ax, 0fffch
	jbe realloc17
	xor ax, ax
	jmp mallocretsp
realloc17:
	inc ax
	and al, 0feh
	mov dx, ax
	inc dx
	inc dx
	mov ax, [bx-2]
	mov di, ax
	sub di, bx
	mov [bp-2], di
	xor di, di
	mov bx, [__empty]
realloc18:
	test bx, bx
	je realloc22
	cmp bx, ax
	ja realloc22
	jne realloc21
	mov ax, [bx-2]
	mov [si-2], ax
	test di, di
	je realloc19
	mov ax, [bx]
	mov [di], ax
	jmp realloc20
realloc19:
	mov ax, [bx]
	mov [__empty], ax
realloc20:
	mov ax, [si-2]
	jmp realloc22
realloc21:
	mov di, bx
	mov bx, [bx]
	jmp realloc18
realloc22:
	mov bx, si
	add bx, dx
	cmp bx, ax
	ja realloc24
	cmp bx, si
	jb realloc24
	lea di, [bx+2]
	cmp di, ax
	jae realloc23
	mov [bx-2], ax
	mov [si-2], bx
	push bx
	call _free
	pop bx  ; Clean up argument of _brk above.
realloc23:
	mov ax, si
	jmp mallocretsp
realloc24:
	push [bp+0ah]
	call _malloc
	mov di, ax
	pop bx  ; Clean up argument of _brk above.
	test ax, ax
	jne realloc26
realloc25:
	jmp mallocretsp
realloc26:
	push [bp-2]
	push si
	push ax
	call _memcpy
	push si
	call _free
	add sp, 8
	mov ax, di
	jmp realloc25
ENDIF  ; U_realloc.

; --- OpenWatcom v2 C compiler (wcc) integer operation helpers.

; Divides signed 32-bit long dividend DX:AX by signed 32-bit long divisor CX:BX, rounds towards 0, saves the quotient to DX:AX, saves the remainder to CX:BX. Ruins FLAGS. Traps on division by 0 or overflow.
; Called by code generated by the OpenWatcom C compiler wcc.
IFDEF U__I4D
PUBLIC __I4D
IFNDEF U__U4D
U__U4D =  ; Make `IFDEF U__U4D' be true below.
ENDIF
__I4D:
	test dx, dx
	js i4ddividendneg
	test cx, cx
	jns __U4D
	neg cx
	neg bx
	sbb cx, 0
	call __U4D
	jmp i4dqneg
i4ddividendneg:
	neg dx
	neg ax
	sbb dx, 0
	test cx, cx
	jns i4drneg
	neg cx
	neg bx
	sbb cx, 0
	call __U4D
	neg cx
	neg bx
	sbb cx, 0
	ret
i4drneg:
	call __U4D
	neg cx
	neg bx
	sbb cx, 0
i4dqneg:
	neg dx
	neg ax
	sbb dx, 0
	ret
ENDIF

; Divides unsigned 32-bit long dividend DX:AX by unsigned 32-bit long divisor CX:BX, rounds towards 0 (same as rounding down for unsigned) saves the quotient to DX:AX, saves the remainder to CX:BX. Ruins FLAGS. Traps on division by 0 or overflow.
; Called by code generated by the OpenWatcom C compiler wcc.
IFDEF U__U4D
PUBLIC __U4D
__U4D:
	test cx, cx
	jnz u4dlargedivisor  ; Jumps iff the divisor doesn't fit to a 16-bit word.
	dec bx
	je u4dretsmall  ; If dividing by 1, it's a no-op, keep the quotient in DX:AX, and keep the remainder 0 in CX:BX.
	inc bx
	cmp bx, dx
	ja u4dlow  ; Jumps iff the quotient fits to a 16-bit word, i.e. if the divisor BX is larger than high word of the dividend (DX). If it jumps, it stores the high word of the quotient in CX, which is 0.
	mov cx, ax
	mov ax, dx
	xor dx, dx
	div bx  ; This traps on division by zero.
	xchg ax, cx
u4dlow:
	div bx
	mov bx, dx  ; BX := low word of the remainder.
	mov dx, cx  ; DX := high word of the quotient.
	xor cx, cx  ; DX := high word of the remainder. It's 0, because the remainder is smaller than the divisor, and the divisor fits to a 16-bit word, so the remainder also does.
u4dretsmall:
	ret
u4dlargedivisor:
	cmp cx, dx
	jb u4dqnonzero  ; Jumps iff the high word of the dividend is larger than the high word of the divisor.
	jne u4dqzero
	cmp bx, ax
	ja u4dqzero  ; Jumps iff the divisor is larger than the dividend.
u4dqone:
	sub ax, bx  ; AX := low word of the remainder.
	xchg bx, ax  ; BX := AX; AX := junk.
	xor cx, cx  ; Set high word of the remainder to 0.
	mov ax, 1
	cwd  ; Set the quotient (DX:AX) to 1.
	ret
u4dqzero:
	xor cx, cx
	xor bx, bx  ; CX:BX := 0.
	xchg ax, bx
	xchg dx, cx  ; Set the remainder (CX:BX) to the dividend, and the quotient (DX:AX) to 0.
	ret
u4dqnonzero:
	push bp
	push si
	xor si, si
	mov bp, si
loc8:
	add bx, bx
	adc cx, cx
	jb loc11
	inc bp
	cmp cx, dx
	jb loc8
	ja loc9
	cmp bx, ax
	jbe loc8
loc9:
	clc
loc10:
	adc si, si
	dec bp
	js loc14
loc11:
	rcr cx, 1
	rcr bx, 1
	sub ax, bx
	sbb dx, cx
	cmc
	jb loc10
loc12:
	add si, si
	dec bp
	js loc13
	shr cx, 1
	rcr bx, 1
	add ax, bx
	adc dx, cx
	jae loc12
	jmp loc10
loc13:
	add ax, bx
	adc dx, cx
loc14:
	mov bx, ax
	mov cx, dx
	mov ax, si
	xor dx, dx
	pop si
	pop bp
	ret
ENDIF

; Multiplies unsigned 32-bit long by unsigned 32-bit long.
; Called by code generated by the OpenWatcom C compiler wcc.
IFDEF U__U4M
PUBLIC __U4M
__U4M:
	; Falls through to __I4M.
IFNDEF DO_I4M
DO_I4M =
ENDIF
ENDIF
;
; Multiplies signed 32-bit long by signed 32-bit long.
; Called by code generated by the OpenWatcom C compiler wcc.
IFDEF U__I4M
PUBLIC __I4M
__I4M:
IFNDEF DO_I4M
DO_I4M =
ENDIF
ENDIF
IFDEF DO_I4M
	xchg ax, bx
	push ax
	xchg ax, dx
	or ax, ax
	je loc15
	mul dx
loc15:
	xchg ax, cx
	or ax, ax
	je loc16
	mul bx
	add cx, ax
loc16:
	pop ax
	mul bx
	add dx, cx
	ret
ENDIF

; --- C library character classification and conversion functions from <ctype.h>.
;
; !! TODO(pts): Add the shorter, __watcall variants, and merge the two if both are needed.

; int isalnum(int c);
IFDEF U_isalnum
PUBLIC _isalnum
_isalnum:
; PUBLIC int isalnum(c) int c; { int i = c & 255; return ((i >= 'A' && i <= 'Z') || (i >= 'a' && i <= 'z') || (i >= '0' && i <= '9')); }
	mov bx, sp
	mov al, [bx+2]
	sub al, '0'
	cmp al, '9'-'0'+1
	jc isalnumfound
	add al, '0'
	or al, 20h
	sub al, 'a'
	cmp al, 'z'-'a'+1
isalnumfound:
	sbb ax, ax
	neg ax
	ret
ENDIF

; int isalpha(int c);
IFDEF U_isalpha
PUBLIC _isalpha
_isalpha:
; PUBLIC int isalpha(c) int c; { int i = c & 255; return ((i >= 'A' && i <= 'Z') || (i >= 'a' && i <= 'z')); }
	mov bx, sp
	mov al, [bx+2]
	or al, 20h
	sub al, 'a'
	cmp al, 'z'-'a'+1
	sbb ax, ax
	neg ax
	ret
ENDIF

; int isascii(int c);
IFDEF U_isascii
PUBLIC _isascii
_isascii:
; PUBLIC int isascii(c) int c; { int i = c & 255; return ((i) >= 0 && (i) <= 127); }
	mov bx, sp
	mov al, [bx+2]
	cmp al, 127+1
	sbb ax, ax
	neg ax
	ret
ENDIF

; int isdigit(int c);
IFDEF U_isdigit
PUBLIC _isdigit
_isdigit:
; PUBLIC int isdigit(c) int c; { int i = c & 255; return (i >= '0' && i <= '9'); }
	mov bx, sp
	mov al, [bx+2]
	sub al, '0'
	cmp al, 10
	sbb ax, ax
	neg ax
	ret
ENDIF

; int islower(int c);
IFDEF U_islower
PUBLIC _islower
_islower:
; PUBLIC int islower(c) int c; { int i = c & 255; return (i >= 'a' && i <= 'z'); }
	mov bx, sp
	mov al, [bx+2]
	sub al, 'a'
	cmp al, 'z'-'a'+1
	sbb ax, ax
	neg ax
	ret
ENDIF

; int isprint(int c);
IFDEF U_isprint
PUBLIC _isprint
_isprint:
; PUBLIC int isprint(c) int c; { int i = c & 255; return ((i) >= 32 && (i) <= 126); }
	mov bx, sp
	mov al, [bx+2]
	sub al, 32  ; ' '.
	cmp al, 126-32+1  ; '~'-' '+1.
	sbb ax, ax
	neg ax
	ret
ENDIF

; int isspace(int c);
IFDEF U_isspace
PUBLIC _isspace
_isspace:
; PUBLIC int isspace(c) int c; { int i = c & 255; return ((i >= 9 && i <= 13) || i == ' '); }
	mov bx, sp
	mov al, [bx+2]
	sub al, 9  ; '\t'
	cmp al, 5  ; '\r'-'\t'+1
	jb isspacelow
	sub al, ' '-9
	cmp al, 1
isspacelow:
	sbb ax, ax
	neg ax
	ret
ENDIF

; int isupper(int c);
IFDEF U_isupper
PUBLIC _isupper
_isupper:
; PUBLIC int isupper(c) int c; { int i = c & 255; return (i >= 'A' && i <= 'Z'); }
	mov bx, sp
	mov al, [bx+2]
	sub al, 'A'
	cmp al, 'Z'-'A'+1
	sbb ax, ax
	neg ax
	ret
ENDIF

; int isxdigit(int c);
IFDEF U_isxdigit
PUBLIC _isxdigit
_isxdigit:
; PUBLIC int isxdigit(c) int c; { int i = c & 255; return ((i >= 'A' && i <= 'F') || (i >= 'a' && i <= 'f') || (i >= '0' && i <= '9')); }
	mov bx, sp
	mov al, [bx+2]
	sub al, '0'
	cmp al, 10
	jb isxdigitdigit
	or al, 20h
	sub al, 'a'-'0'
	cmp al, 6
isxdigitdigit:
	sbb ax, ax
	neg ax
	ret
ENDIF

; int tolower(int c);
IFDEF U_tolower
PUBLIC _tolower
_tolower:
; PUBLIC int tolower(c) int c; { int i = c & 255; return (i >= 'A' && i <= 'Z') ? i + 'a' - 'A' : c; }
	mov bx, sp
	mov ax, [bx+2]
	cmp al, 'A'
	jb tolowerkeep
	cmp al, 'Z'
	ja tolowerkeep
	add al, 'a'-'A'
tolowerkeep:
	ret
ENDIF

; int toupper(int c);
IFDEF U_toupper
PUBLIC _toupper
_toupper:
; PUBLIC int toupper(c) int c; { int i = c & 255; return (i >= 'a' && i <= 'z') ? i + 'A' - 'a' : c; }
	mov bx, sp
	mov ax, [bx+2]
	cmp al, 'a'
	jb toupperkeep
	cmp al, 'z'
	ja toupperkeep
	add al, 'A'-'a'
toupperkeep:
	ret
ENDIF

; --- C library string functions (str...(3) and mem...(3)) from <string.h>.

; void *memcpy(void *s1, const void *s2, size_t n);
;
; Copies n characters from the object pointed to by s2 into the
; object pointed to by s1.  Copying takes place as if the n
; characters pointed to by s2 are first copied to a temporary
; area and then copied to the object pointed to by s1.
; Returns s1.
;
; Per X3J11, memcpy may have undefined results if the objects
; overlap; since the performance penalty is insignificant, we
; use the safe memmove code for it as well.
;
; !! TODO(pts): If both memmove and memcpy are used in a program, make memcpy an alias to memmove.
IFDEF U_memcpy
PUBLIC _memcpy
_memcpy:
	mov bx, si  ; Save SI to BX.
	mov dx, di  ; Save DI to DX.
	mov di, sp
	mov cx, [di+6]  ; Argument n.
	mov si, [di+4]  ; Argument s2.
	mov di, [di+2]  ; Argument s1.
	mov ax, di  ; Save a copy of s1, for returning.
	rep movsb
	mov di, dx  ; Restore DI. DX := junk.
	mov si, bx  ; Restore SI. BX := junk.
	ret
ENDIF

; void *memset(void *s, int c, size_t n);
;
; Copies the value of c (converted to unsigned char) into the
; first n locations of the object pointed to by s.
; Returns s.
IFDEF U_memset
PUBLIC _memset
_memset:
	mov dx, ds
	mov es, dx  ; ES := DS. This is needed even with `wcc -r', because the code generated by the OpenWatcom C compiler (wcc) for a switch--case may ruin ES.
	mov dx, di  ; Save DI to DX.
	mov di, sp
	mov cx, [di+6]  ; Argument n.
	mov al, [di+4]  ; Argument c.
	mov di, [di+2]  ; Argument s.
	mov bx, di  ; Save a copy of s, for returning.
	rep stosb  ; Uses ES. Must be same as DS.
	xchg ax, bx  ; AX := s; BX := junk.
	mov di, dx  ; Restore DI. DX is now junk.
	ret
ENDIF

; int strcmp(const char *s1, const char *s2);
;
; Compares the strings pointed to by s1 and s2.  Returns zero if
; strings are identical, a positive number if s1 greater than s2,
; and a negative number otherwise.
IFDEF U_strcmp
PUBLIC _strcmp
_strcmp:
	mov dx, ds
	mov es, dx  ; ES := DS. This is needed even with `wcc -r', because the code generated by the OpenWatcom C compiler (wcc) for a switch--case may ruin ES.
	mov bx, si  ; Save SI to BX.
	mov dx, di  ; Save DI to DX.
	mov si, sp
	mov di, [si+4]  ; Argument s2.
	mov si, [si+2]  ; Argument s1.
strcmpnext:
	lodsb
	scasb  ; Uses ES. Must be same as DS.
	jne strcmpdiff
	cmp al, 0
	jne strcmpnext
	xor ax, ax
	jmp strcmpdone
strcmpdiff:
	sbb ax, ax
	or al, 1
strcmpdone:
	mov di, dx  ; Restore DI. DX := junk.
	mov si, bx  ; Restore SI. BX := junk.
	ret
ENDIF

; char *strcpy(char *s1, const char *s2);
;
; Copy the string pointed to by s2, including the terminating null
; character, into the array pointed to by s1.  Returns s1.
IFDEF U_strcpy
PUBLIC _strcpy
_strcpy:
IFDEF U_strcat
	call strcpysetup
ELSE
	mov dx, ds
	mov es, dx  ; ES := DS. This is needed even with `wcc -r', because the code generated by the OpenWatcom C compiler (wcc) for a switch--case may ruin ES.
	mov bx, si  ; Save SI to BX.
	mov dx, di  ; Save DI to DX.
	mov di, sp
	mov si, [di+4]  ; Argument s2.
	mov di, [di+2]  ; Argument s1.
	mov cx, di  ; Save a copy of s1, for returning.
ENDIF
strcpynext:
	lodsb
	stosb  ; Uses ES. Must be same as DS.
	test al, al
	jnz strcpynext
	xchg ax, cx  ; AX := s1; CX := junk.
	mov di, dx  ; Restore DI. DX := junk.
	mov si, bx  ; Restore SI. BX := junk.
	ret
IFDEF U_strcat
strcpysetup:  ; Code shared by _strcpy and _strcat.
	mov dx, ds
	mov es, dx  ; ES := DS. This is needed even with `wcc -r', because the code generated by the OpenWatcom C compiler (wcc) for a switch--case may ruin ES.
	mov bx, si  ; Save SI to BX.
	mov dx, di  ; Save DI to DX.
	mov di, sp
	mov si, [di+6]  ; Argument s2.
	mov di, [di+4]  ; Argument s1.
	mov cx, di  ; Save a copy of s1, for returning.
	ret
ENDIF
ENDIF

; char *strcat(char *s1, const char *s2)
;
; Concatenates the string pointed to by s2 onto the end of the
; string pointed to by s1.  Returns s1.
IFDEF U_strcat
PUBLIC _strcat
_strcat:
IFDEF U_strcpy
	call strcpysetup
ELSE
	mov dx, ds
	mov es, dx  ; ES := DS. This is needed even with `wcc -r', because the code generated by the OpenWatcom C compiler (wcc) for a switch--case may ruin ES.
	mov bx, si  ; Save SI to BX.
	mov dx, di  ; Save DI to DX.
	mov di, sp
	mov si, [di+4]  ; Argument s2.
	mov di, [di+2]  ; Argument s1.
	mov cx, di  ; Save a copy of s1, for returning.
ENDIF
	mov al, 0
strcatnext:
	scasb  ; Uses ES. Must be same as DS.
	jne strcatnext
	dec di  ; Undo the skipping over the last NUL.
IFDEF U_strcpy
	jmp strcpynext
ELSE
strcatcopynext:
	lodsb
	stosb  ; Uses ES. Must be same as DS.
	test al, al
	jnz strcatcopynext
	xchg ax, cx  ; AX := s1; CX := junk.
	mov di, dx  ; Restore DI. DX := junk.
	mov si, bx  ; Restore SI. BX := junk.
	ret
ENDIF
ENDIF

; size_t strlen(const char *s);
;
; Returns the length of the string pointed to by s.
IFDEF U_strlen
PUBLIC _strlen
_strlen:
	mov bx, sp
	mov bx, [bx+2]  ; Argument s.
__strlenbx:  ; Other libc functions may call this entry point to get the length of the string starting at BX.
	xchg bx, di  ; Save DI to BX.
	mov cx, ds
	mov es, cx  ; ES := DS. This is needed even with `wcc -r', because the code generated by the OpenWatcom C compiler (wcc) for a switch--case may ruin ES.
	mov cx, -1
	xor al, al  ; Also sets ZF := 1, which is needed below for the emptry string.
	repne scasb  ; Uses ES. Must be same as DS.
	not cx  ; Silly trick gives length (including the NUL byte).
	dec cx  ; Forget about the NUL byte.
	xchg ax, cx  ; AX := result; CX := junk.
	mov di, bx  ; Restore DI.
	ret
ENDIF

; char *strchr(const char *s, int c);
; char *index (const char *s, int c);
;
; Locates first occurrence of c (as unsigned char) in string s.
IFDEF U_strchr
PUBLIC _strchr
ENDIF
IFDEF U_index
PUBLIC _index
_index:
IFNDEF U_strchr
U_strchr =
ENDIF
ENDIF
IFDEF U_strchr
_strchr:
	mov bx, si  ; Save SI.
	mov si, sp
	mov ah, [si+4]  ; Argument c.
	mov si, [si+2]  ; Argument s.
strchrnext:
	lodsb
	cmp al, ah
	je strchrfound
	test al, al
	jnz strchrnext
	mov si, 1  ; Not found, we will return NULL, but +1 to compensate for the `dec ax' below.
strchrfound:
	xchg ax, si  ; AX := SI; SI := junk.
	dec ax  ; Make DX point to the first occurrence of c, not after it.
	mov si, bx  ; Restore SI. BX is now junk.
	ret
ENDIF

; char *strrchr(const char *s, int c);
; char *rindex (const char *s, int c);
;
; Locates final occurrence of c (as unsigned char) in string s.
IFDEF U_strrchr
PUBLIC _strrchr
ENDIF
IFDEF U_rindex
PUBLIC _rindex
_rindex:
IFNDEF U_strrchr
U_strrchr =
ENDIF
ENDIF
IFDEF U_strrchr
_strrchr:
	mov bx, si  ; Save SI.
	mov si, sp
	mov ah, [si+4]  ; Argument c.
	mov si, [si+2]  ; Argument s.
	xor dx, dx  ; Initial return value of NULL.
strrchrnext:
	lodsb
	cmp al, ah
	jne strrchrdiff
	mov dx, si
	dec dx  ; Make DX point to the last occurrence of c, not after it.
strrchrdiff:
	test al, al
	jnz strrchrnext
	xchg ax, dx  ; AX := pointer to last match; DX := junk.
	mov si, bx  ; Restore SI. BX is now junk.
	ret
ENDIF

; int strncmp(const char *s1, const char *s2, size_t n);
;
; Compares up to n characters from the strings pointed to by s1
; and s2.  Returns zero if the (possibly null terminated) arrays
; are identical, a positive number if s1 is greater than s2, and
; a negative number otherwise.
IFDEF U_strncmp
PUBLIC _strncmp
_strncmp:
	mov dx, ds
	mov es, dx  ; ES := DS. This is needed even with `wcc -r', because the code generated by the OpenWatcom C compiler (wcc) for a switch--case may ruin ES.
	mov bx, si  ; Save SI to BX.
	mov dx, di  ; Save DI to DX.
	mov si, sp
	mov cx, [si+6]  ; Argument n.
	jcxz strncmpequal
	mov di, [si+4]  ; Argument s2.
	mov si, [si+2]  ; Argument s1.
strncmpnext:
	lodsb
	scasb  ; Uses ES. Must be same as DS.
	je strncmpsame
	sbb ax, ax
	sbb ax, -1  ; With the previous instruction: AX := (CF ? -1 : 1).
	jmp strncmpret
strncmpsame:
	test al, al
	jz strncmpequal
	loop strncmpnext
strncmpequal:
	xor ax, ax
strncmpret:
	mov di, dx  ; Restore DI. DX := junk.
	mov si, bx  ; Restore SI. BX := junk.
	ret
ENDIF

; int memcmp(const void *s1, const void *s2, size_t n)
;
; Compares the first n characters of the objects pointed to by
; s1 and s2.  Returns zero if all characters are identical, a
; positive number if s1 greater than s2, a negative number otherwise.
IFDEF U_memcmp
PUBLIC _memcmp
_memcmp:
	mov dx, ds
	mov es, dx  ; ES := DS. This is needed even with `wcc -r', because the code generated by the OpenWatcom C compiler (wcc) for a switch--case may ruin ES.
	mov bx, si  ; Save SI to BX.
	mov dx, di  ; Save DI to DX.
	mov si, sp
	mov cx, [si+6]  ; Argument n.
	mov di, [si+4]  ; Argument s2.
	mov si, [si+2]  ; Argument s1.
	xor ax, ax  ; Also sets ZF := 1, which is needed below for the emptry string.
	repe cmpsb  ; Continue while equal. Uses ES. Must be same as DS.
	je memcmpret
	inc ax
	jnc memcmpret
	neg ax
memcmpret:
	mov di, dx  ; Restore DI. DX := junk.
	mov si, bx  ; Restore SI. BX := junk.
	ret
ENDIF

_TEXT ENDS

END _cstart_  ; _cstart_ will be the program entry point.
