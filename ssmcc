#!/bin/sh --
#
# ssmcc: simple small model C compiler driver, using OpenWatcom v2
# by pts@fazekas.hu at Thu Jan 29 16:08:36 CET 2026
#
# Quick try (run the commands on Linux i386 or amd64, without the leading `$`):
#
#   $ owcc  # Check that it's properly installed.
#   $ echo 'int main() { return write(1, "Hello, World\n", 14) == 14; }' >hw.c
#   $ ./ssmcc -bminix -Os -Wno-n131 -o hw hw.c
#   $ ls -l hw
#
# After installing OpenWatcom v2 (and having the owcc, wcc and wlink tools
# on your $PATH; no need to set $WATCOM) and adding the directory of this
# script to your $PATH, compile your C probram like this:
#
#   $ ssmcc -bminix -Os -W -Wall -o myprog myprog.c
#   $ ssmcc -belks  -Os -W -Wall -o myprog myprog.c
#
# ssmcc accepts the same command-line arguments as owcc (the OpenWatacom v2
# C compiler Unix driver), which is similar to GCC and Clang.
#
# TODO(pts): Write libc and try with -mabi=watcall. Does it get significantly shorter?
#

test "$ZSH_VERSION" && set -y 2>/dev/null  # SH_WORD_SPLIT for zsh(1). It's an invalid option in bash(1), and it's harmful (prevents echo) in ash(1).

case "$0" in */*) ssmccdir="${0%/*}" ;; *) ssmccdir=. ;; esac
if test -f "$ssmccdir/ssmcc.asm"; then :; else echo "fatal: missing ssmcc assembly source file: $ssmccdir/ssmcc.asm" >&2; exit 2; fi

unset LANG LANGUAGE  # For deterministic output.
export LC_ALL=C  # For deterministic output. Typically not needed.
export TZ=GMT  # For deterministic output. Typically not needed.
unset INCLUDE  # Don't let the OpenWatcom v2 C compiler find the OpenWatcom v2 libc include files (*.h).
export LIB=/dev/null/missing  # Don't let the OpenWatcom v2 linker (WLINK) find the OpenWatcom v2 libc library files (*.lib).
export LIBRARY=/dev/null/missing  # Don't let the OpenWatcom v2 linker (WLINK) find the OpenWatcom v2 libc library files (*.lib). (Does this make any difference?)
export WLINK=/dev/null/missing  # Don't let the OpenWatcom v2 linker (WLINK) find its own config file. (Does this make any difference?)
export WLINK_LNK=/dev/null/missing  # Don't let the OpenWatcom v2 linker (WLINK) find its own config file. Typical default value is WLINK_LNK=wlink.lnk
unset WATCOM  # Don't let the OpenWatcom v2 linker (WLINK) find its own config file (so `owcc -bdos' and `wlink form dos' won't work). Typical default location is $WATCOM/$WLINK_LNK

## Figure out the target operating system ("$os").
case "$1" in
 -belks) cdefs="-D__ELKS__ -D__ELKS -D__elks__ -D__elks -D__unix__"; wasmdefs="-Wc,-d__ELKS__"; shift ;;  # Dev86 has -D__ELKS__ -D__unix__.
 -bminix | -bminixi86) cdefs="-D__MINIX__ -D__MINIX -D__minix__ -D__minix -D__unix__"; wasmdefs="-Wc,-d__MINIX__"; shift ;;  # The ACK ANSI C compiler 1.202 on Minix >=1.7.0 has -D__MINIX. The non-ANSI ACK 3.1 C compiler on Minix 1.5.10 doesn't have anything.
 *) echo "fatal: please specify -bminix or -belks first" >&2; exit 2 ;;
esac
cdefs="-D__SSMCC__ -D__SIZEOF_INT__=2 -D__SIZEOF_LONG__=4 -D__SIZEOF_POINTER__=2 $cdefs"; wasmdefs="-Wc,-d__SSMCC__ $wasmdefs"

## Figure out the output executable program filename ($ofn) from the command-line arguments ("$@").
next=
for arg in "$@"; do
  case "$next" in o) ofn="$arg"; next= ;; esac
  case "$arg" in -o) next=o ;; -o*) ofn="${arg#??}" ;; esac
done
case "$ofn" in "") ofn=a.out; set x -o "$ofn" "$@"; shift ;; esac

## Compile the program using the OpenWatcom v2 C compiler (wcc) started by the OpenWatcom v2 C compiler Unix driver (owcc).
# This creates some OMF-format object files (*.o) in the current directory, and doesn't clean them up later. This is normal behavior of owcc (but not gcc or clang), we keep it.
owcc -bbegin -march=i86 -Wl,x -Wl,end -Wl,form -Wl,dos -fno-stack-check -mcmodel=s -mabi=cdecl -fnostdlib -fsigned-char -Wl,op -Wl,start=_cstart_ -Wl,op -Wl,d -Wl,op -Wl,stack=1 -Wl,disable -Wl,1172 -s $cdefs "$@"  >ssmcc.err 2>&1
# Compile a list of undefined symbols. Example: undefs="-Wc,-dU_cstart_ -Wc,-dU_write -Wc,-dU__argc"
undefs="$(perl -e 'my $xc = 77; my @s; while (<STDIN>) { if (m@^Error! E[^:]+: (\S+) is an undefined reference$@) { push(@s, "-Wc,-dU$1"); $xc = 0 } } print("@s\n"); exit($xc)' <ssmcc.err)"; xcu="$?"
case "$xcu" in
 77) perl -pe "" <ssmcc.err >&2; rm -f ssmcc.err; exit 3 ;;  # No undefined symbols found, so there must be some other owcc error. `cat' would also work instead of (and would be faster than) `perl -pe ""', but that would be 1 extra external command dependency.
 0) rm -f ssmcc.err ;;  # Found some undefined symbols, saved them to $undefs.
 *) rm -f ssmcc.err; echo "fatal: error running Perl to find the libc functions used" >&2; exit 4 ;;
esac
rm -f ssmcc.err
owcc -bdos -s -mcmodel=s -c $wasmdefs $undefs -o ssmcc.o "$ssmccdir"/ssmcc.asm || exit "$?"
# ssmcc.o must be specified first, because $edata is expected right after the DOS MZ .exe header, i.e. at the beginning of _TEXT.
owcc -bbegin -march=i86 -Wl,x -Wl,end -Wl,form -Wl,dos -fno-stack-check -mcmodel=s -mabi=cdecl -fnostdlib -fsigned-char -Wl,op -Wl,stack=1 -Wl,disable -Wl,1172 -s $cdefs ssmcc.o "$@" || exit "$?"
rm -f ssmcc.o

## Change the first 0x22 bytes of the executable file, i.e. replace the DOS MZ .exe header with the Minix and ELKS a.out header.
perl -we 'use integer; use strict;
    my $fn = $ARGV[0]; my $fno = $fn; substr($fno, 0, 0) = "./" if $fno !~ m@^[.\w/]@;
    die("fatal: error opening: $fn\n") if !open(F, "+< $fno");
    die("fatal: error reeding header: $fn\n") if (sysread(F, $_, 0x22) or 0) != 0x22;
    die("fatal: error getting file size: $fn\n") if !(my $size = sysseek(F, 0, 2));  # Rewind for writing below.
    die("fatal: error seeking to start of file: $fn\n") if !sysseek(F, 0, 0);  # Rewind for writing below.
    my($signature, $lastsize, $nblocks, $nreloc, $hdrsize, $minalloc, $maxalloc, $ss, $sp, $checksum, $ip, $cs, $relocpos, $noverlay, $edata) = unpack("a2v13x4v", $_);
    die("fatal: missing DOS MZ .exe signature: $fn\n") if $signature ne "MZ";
    die("fatal: bad DOS MZ .exe header: $fn\n") if $lastsize > 0x200 or $nblocks == 0 or $nreloc != 0 or $hdrsize != 2 or $ss == 0 or $cs != 0 or $ip != 0;
    my $a_magic = "\x01\x03";  # Minix and ELKS a.out header signature (magic).
    my $a_flags = 0x20;  # Executable program with separate I&D. Corresponds to `owcc -mcmodel=s` (small model).
    my $a_cpu = 4;  # A_I8086 == 4; A_I80386 == 0x10.
    my $a_hdrlen = 0x20;
    my $a_unused = 0;  # Must be 0 for Minix.
    my $a_version = 0;  # Must be 0 for Minix.
    my $a_text = ((($size + 1) & ~1) - 0x20) - $edata;
    my $a_data = $edata;
    my $a_bss = (($ss << 4 | $sp) - 1) - ((($size + 1) & ~1) - 0x20);  # -1 is because of `wlink op stack=1`.
    my $a_entry = 0;  # Must be 0 for Minix 1.5.10.
    my $a_total = 0x10000;  # Typical to maximize the data segment.
    my $a_syms = 0;  # Exeutable stripped.
    my $instr2 = "\xfc\x59";  # Put `cld ++ push cx` back to the beginning of _cstart_.
    $_ = pack("a2CCCCvV6a2", $a_magic, $a_flags, $a_cpu, $a_hdrlen, $a_unused, $a_version, $a_text, $a_data, $a_bss, $a_entry, $a_total, $a_syms, $instr2);
    die("fatal: error writing header: $fn\n") if (syswrite(F, $_, 0x22) or 0) != 0x22;
    ' "$ofn" || exit "$?"
# chmod +x -- "$ofn"  # Not needed, owcc makes it executable on Linux.
