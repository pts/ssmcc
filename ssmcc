#!/bin/sh --
#
# ssmcc: simple small model C compiler for i86 Unix-like, using OpenWatcom v2
# by pts@fazekas.hu at Thu Jan 29 16:08:36 CET 2026
#
# ssmcc is designed to run on any modern Linux i386 or Linux amd64 system
# out-of-the-box (it doesn't matter which distro). It's self-contained: the
# repository has all the programs it needs precompiled and saved to the the
# tools/ directory.
#
# Quick try (run the commands without the leading `$'):
#
#   $ echo 'int main() { return write(1, "Hello, World!\n", 14) != 14; }' >hw.c
#   $ ./ssmcc -belks -Os -Wno-n131 -o hwe hw.c
#   $ ls -l hwe
#   -rwxrwxr-x 1 user user 131 Jan 31 16:35 hwe
#   $ ./ssmcc --elksemu ./hwe
#   Hello, World!
#   $ _
#
# Some other examples:
#
#   $ ssmcc -bminix -Os -W -Wall -o myprog myprog.c  # Targets Minix i86.
#   $ ssmcc -belks  -Os -W -Wall -o myprog myprog.c  # Targets ELKS.
#
# ssmcc accepts the same command-line arguments as owcc (the OpenWatcom v2
# C compiler Unix driver), which is similar to GCC and Clang.
#
# TODO(pts): Write libc and try with -mabi=watcall. Does it get significantly shorter?
#

## Shell script setup.
case "$0" in */*) ssmccdir="${0%/*}" ;; *) ssmccdir=. ;; esac
if test "$1" != --sh-env; then  # Run the rest of the script with the bundled BusyBox (in tools/), if found.
  test -f "$ssmccdir/tools/busybox-minicc-1.21.1.upx" && exec "$ssmccdir/tools/busybox-minicc-1.21.1.upx" sh "$0" --sh-env "$@"
else
  shift
fi
test "$ZSH_VERSION" && set -y 2>/dev/null  # SH_WORD_SPLIT for zsh(1). It's an invalid option in bash(1), and it's harmful (prevents echo) in ash(1).

## Environment variable setup.
unset LANG LANGUAGE  # For deterministic output.
export LC_ALL=C  # For deterministic output. Typically not needed.
export TZ=GMT  # For deterministic output. Typically not needed.
unset INCLUDE  # Don't let the OpenWatcom v2 C compiler find the OpenWatcom v2 libc include files (*.h).
export LIB=/dev/null/missing  # Don't let the OpenWatcom v2 linker (WLINK) find the OpenWatcom v2 libc library files (*.lib).
export LIBRARY=/dev/null/missing  # Don't let the OpenWatcom v2 linker (WLINK) find the OpenWatcom v2 libc library files (*.lib). (Does this make any difference?)
export WLINK=/dev/null/missing  # Don't let the OpenWatcom v2 linker (WLINK) find its own config file. (Does this make any difference?)
export WLINK_LNK=/dev/null/missing  # Don't let the OpenWatcom v2 linker (WLINK) find its own config file. Typical default value is WLINK_LNK=wlink.lnk
unset WATCOM  # Don't let the OpenWatcom v2 linker (WLINK) find its own config file (so `owcc -bdos' and `wlink form dos' won't work). Typical default location is $WATCOM/$WLINK_LNK

## Tool path setup.
if test -f "$ssmccdir"/ssmcc.asm; then :; else echo "fatal: missing ssmcc assembly source file: $ssmccdir/ssmcc.asm" >&2; exit 2; fi
if test -f "$ssmccdir"/tools/owcc-ow2023-03-04.upx; then
  perl="$ssmccdir"/tools/miniperl-5.004.04.upx
  owcc="$ssmccdir"/tools/owcc-ow2023-03-04.upx
  elksemu="$ssmccdir"/tools/elksemu-2023-01-12b
  #wasm="$ssmccdir"/tools/wasm-ow2023-03-04.upx    # Not run directly.
  #wcc="$ssmccdir"/tools/wcc-ow2023-03-04.upx      # Not run directly.
  #wlink="$ssmccdir"/tools/wlink-ow2023-03-04.upx  # Not run directly.
  tpath="$ssmccdir/tools:$PATH"  # Make "$owcc" find wasm, wcc and wlink in tools/ .
else
  perl=perl
  owcc=owcc
  elksemu=elksemu
  tpath="$PATH"
fi

## Figure out the target operating system ("$iselks") and memory ("$heapstack").
case "$1" in elksemu | --elksemu) shift; exec "$elksemu" "$@"; exit 1 ;; esac
iselks=; heapstack=max; cdefs=; wasmdefs=
while :; do
  case "$1" in
   -belks) iselks=1; cdefs="-D__ELKS__ -D__ELKS -D__elks__ -D__elks -D__unix__"; wasmdefs="-Wc,-d__ELKS__"; shift; continue ;;  # Dev86 has -D__ELKS__ -D__unix__.
   -bminix | -bminixi86) iselks=0; cdefs="-D__MINIX__ -D__MINIX -D__minix__ -D__minix -D__unix__"; wasmdefs="-Wc,-d__MINIX__"; shift; continue ;;  # The ACK ANSI C compiler 1.202 on Minix >=1.7.0 has -D__MINIX. The non-ANSI ACK 3.1 C compiler on Minix 1.5.10 doesn't have anything.
   -mheapstack=*) heapstack="${1#*=}"; shift; continue ;;
  esac
  break
done
if test -z "$iselks"; then  echo "fatal: please specify -bminix or -belks first" >&2; exit 3 ; fi
cdefs="-D__SSMCC__ -D__SIZEOF_INT__=2 -D__SIZEOF_LONG__=4 -D__SIZEOF_POINTER__=2 $cdefs"; wasmdefs="-Wc,-d__SSMCC__ $wasmdefs"

## Figure out the system include directory.
if test -f "$ssmccdir/include/stddef.h"; then sysinc="$ssmccdir/include"
elif test -d "$ssmccdir/../ssmccinclude/stddef.h"; then sysinc="$ssmccdir/../ssmccinclude"
else echo "fatal: ssmcc system include directory not found near: $ssmccdir" >&2; exit 4
fi
export INCLUDE="$sysinc"  # Respected by OpenWatcom v2 C compiler (wcc) called by owcc.

## Figure out the output executable program filename ($ofn) from the command-line arguments ("$@"), and whether we are linking.
next=; dolink=1; vflag=
for arg in "$@"; do
  case "$next" in o) ofn="$arg"; next= ;; esac
  case "$arg" in -o) next=o ;; -o*) ofn="${arg#??}" ;; -[EcS]) dolink=0 ;; -v) vflag=-v ;; esac
done

## If not linking, then just run the compiler driver owcc.
case "$dolink" in 0) owcc -bbegin -march=i86 -fno-stack-check -mcmodel=s -mabi=cdecl -fnostdlib -fsigned-char $cdefs "$@"; exit "$?" ;; esac
case "$ofn" in "") ofn=a.out; set x -o "$ofn" "$@"; shift ;; esac
errfn="$ofn".ssmcc.err; case "$errfn" in [/_a-zA-Z0-9]*) ;; *) errfn=./"$errfn"; esac
libcofn="$ofn".ssmcc.o; case "$libcofn" in [/_a-zA-Z0-9]*) ;; *) libcofn=./"$libcofn"; esac

## Compile the program using the OpenWatcom v2 C compiler (wcc) started by the OpenWatcom v2 C compiler Unix driver (owcc).
# This creates some OMF-format object files (*.o) in the current directory, and doesn't clean them up later. This is normal behavior of owcc (but not gcc or clang), we keep it.
PATH="$tpath" "$owcc" -bbegin -march=i86 -Wl,x -Wl,end -Wl,form -Wl,dos -fno-stack-check -mcmodel=s -mabi=cdecl -fnostdlib -fsigned-char -Wl,op -Wl,start=_cstart_ -Wl,op -Wl,d -Wl,op -Wl,stack=1 -Wl,disable -Wl,1172 -s $cdefs "$@"  >"$errfn" 2>&1
# Compile a list of undefined symbols. Example: undefs="-Wc,-dU_cstart_ -Wc,-dU_write -Wc,-dU__argc"
undefs="$("$perl" -e 'my $xc = 77; my @s; while (<STDIN>) { if (m@^Error! E[^:]+: (\S+) is an undefined reference$@) { push(@s, "-Wc,-dU$1"); $xc = 0 } } print("@s\n"); exit($xc)' <"$errfn")"; xcu="$?"
case "$xcu" in
 77) perl -pe "" <"$errfn" >&2; rm -f "$errfn"; exit 5 ;;  # No undefined symbols found, so there must be some other owcc error. `cat' would also work instead of (and would be faster than) `perl -pe ""', but that would be 1 extra external command dependency.
 0) rm -f "$errfn" ;;  # Found some undefined symbols, saved them to $undefs.
 *) rm -f "$errfn"; echo "fatal: error running Perl to find the libc functions used" >&2; exit 6 ;;
esac
rm -f "$errfn"
# Specifying `-mcmodel=s' would be a mistake here: it would cause `wasm -ms', which would make wasm put _DATA before CONST into "$libcofn", which wlink would keep.
PATH="$tpath" "$owcc" -bdos $vflag -s -c $wasmdefs $undefs -o "$libcofn" "$ssmccdir"/ssmcc.asm || exit "$?"
# "$libcofn" must be specified first, because $edata is expected right after the DOS MZ .exe header, i.e. at the beginning of _TEXT.
# TODO(pts): size optimization: Reuse the .o files created in the run of owcc above.
PATH="$tpath" "$owcc" -bbegin -march=i86 -Wl,x -Wl,end -Wl,form -Wl,dos -fno-stack-check -mcmodel=s -mabi=cdecl -fnostdlib -fsigned-char -Wl,op -Wl,stack=1 -Wl,disable -Wl,1172 -s $cdefs "$libcofn" "$@" || exit "$?"
rm -f "$libcofn"

## Change the first 0x22 bytes of the executable file, i.e. replace the DOS MZ .exe header with the Minix and ELKS a.out header.
"$perl" -we 'use integer; use strict;
    my($fn, $iselks, $vflag, $heapstack) = @ARGV; my $fno = $fn; substr($fno, 0, 0) = "./" if $fno !~ m@^[.\w/]@;
    my $heapstack0 = $heapstack;
    $heapstack = ($heapstack eq "max") ? 0x10000 : ($heapstack eq "min") ? 0x200 : ($heapstack =~ m@^0[xX]([0-9a-fA-F]+)\Z(?!\n)@) ? hex($1) : ($heapstack =~ m@^(0[0-7]*)\Z(?!\n)@) ? hex($1) : ($heapstack =~ m@^(\d+)\Z(?!\n)@) ? int($1) : undef;  # Minix `chmem =...` value.
    die("fatal: bad unsigned integer for -mheapstack=: $heapstack0\n") if !defined($heapstack);
    my $os = $iselks ? "ELKS" : "Minix i86";
    print(STDERR "ssmcc: converting DOS MZ .exe program to $os a.out executable: $fn\n") if $vflag;
    die("fatal: error opening: $fn\n") if !open(F, "+< $fno");
    die("fatal: error reeding header: $fn\n") if (sysread(F, $_, 0x22) or 0) != 0x22;
    die("fatal: error getting file size: $fn\n") if !(my $size = sysseek(F, 0, 2));  # Rewind for writing below.
    die("fatal: error seeking to start of file: $fn\n") if !sysseek(F, 0, 0);  # Rewind for writing below.
    my($signature, $lastsize, $nblocks, $nreloc, $hdrsize, $minalloc, $maxalloc, $ss, $sp, $checksum, $ip, $cs, $relocpos, $noverlay, $edata) = unpack("a2v13x4v", $_);
    die("fatal: missing DOS MZ .exe signature: $fn\n") if $signature ne "MZ";
    die("fatal: bad DOS MZ .exe header: $fn\n") if $lastsize > 0x200 or $nblocks == 0 or $nreloc != 0 or $hdrsize != 2 or $ss == 0 or $cs != 0 or $ip != 0;
    my $a_magic = "\x01\x03";  # Minix and ELKS a.out header signature (magic).
    my $a_flags = 0x20;  # Executable program with separate I&D. Corresponds to `owcc -mcmodel=s` (small model). Minix (but not ELKS) also supports $_flags == 0x10 (common I&D).
    my $a_cpu = 4;  # A_I8086 == 4; A_I80386 == 0x10.
    my $a_hdrlen = 0x20;
    my $a_unused = 0;  # Must be 0 for Minix.
    my $a_version = 0;  # Must be 0 for Minix.
    my $a_text = $size - $edata - 0x20;
    die("fatal: a_text too large (too much code): $a_text: $fn\n") if $a_text > 0xff00;  # 0xff00 is the Minix 1.5.10 maximum.
    my $a_data = $edata;
    my $a_bss = (($ss << 4 | $sp) - 1) - ($size - 0x20);  # -1 is because of `wlink op stack=1`.
    my $a_entry = 0;  # Must be 0 for Minix 1.5.10.
    my $a_total = $a_data + $a_bss;
    die("fatal: a_data+a_bss too large: $a_total: $fn\n") if $a_total > 0xfe00;  # Leave 0x200 bytes for stack (including argv strings and environ strings).
    my $a_total_max = $iselks ? 0xfff0 : 0x10000;  # Typical to maximize the data segment. ELKS would treat 0x10000 as 0, too little for sbrk(...). 0xffff gives: argument list too long.
    $a_total = ($a_total + $heapstack <= $a_total_max) ? $a_total + $heapstack : $a_total_max;
    my $a_syms = 0;  # Exeutable stripped.
    my $instr2 = "\xfc\x58";  # Put `cld ++ pop ax` back to the beginning of _cstart_.
    $_ = pack("a2CCCCvV6a2", $a_magic, $a_flags, $a_cpu, $a_hdrlen, $a_unused, $a_version, $a_text, $a_data, $a_bss, $a_entry, $a_total, $a_syms, $instr2);
    die("fatal: error writing header: $fn\n") if (syswrite(F, $_, 0x22) or 0) != 0x22;
    # TODO(pts): Remove the trailing NUL bytes at the end of .text, make $a_text smaller.
    ' "$ofn" "$iselks" "$vflag" "$heapstack" || exit "$?"
# chmod +x -- "$ofn"  # Not needed, owcc makes it executable on Linux.
